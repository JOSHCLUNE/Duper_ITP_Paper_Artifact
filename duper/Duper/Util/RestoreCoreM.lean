import Lean
import Duper.Tactic
import Duper.TPTP
open Lean
-- Desperate time, desperate measures
-- This file is generated by RestoreCoreMCodeGen.lean

-- Names being added:
  -- Eq
  -- Not
  -- True
  -- False
  -- Duper.clausify_not
  -- Exists
  -- Or
  -- Duper.exists_hoist_proof
  -- And
  -- Duper.clausify_and_false
  -- Duper.rule20Theorem
  -- Duper.c1_soundness
  -- HEq
  -- HEq.ndrec
  -- Duper.clausify_or_false_right
  -- Duper.clausify_imp
  -- Duper.true_ne_false
  -- Ne
  -- Duper.clausify_prop_inequality1
  -- Bool
  -- Bool.false
  -- Bool.true
  -- Duper.bool_false_ne_true
  -- Iff
  -- Duper.rule28Theorem
  -- Duper.rule6Theorem
  -- Duper.rule15Theorem
  -- Duper.prop_true_ne_false
  -- Setoid
  -- HasEquiv
  -- HasEquiv.Equiv
  -- instHasEquiv
  -- Setoid.symm
  -- Duper.of_not_eq_false
  -- HEq.elim
  -- Duper.rule12Theorem
  -- Duper.rule21Theorem
  -- Duper.rule3Theorem
  -- Duper.exists_of_forall_eq_false
  -- Duper.equality_factoring_soundness4
  -- List
  -- List.Mem
  -- List.Mem.below
  -- List.Mem.brecOn
  -- Duper.rule14Theorem
  -- HEq.symm
  -- Duper.eq_hoist_proof
  -- LT
  -- List.lt
  -- List.lt.below
  -- List.lt.brecOn
  -- Duper.clausify_and_right
  -- Duper.rule5Theorem
  -- Duper.clausify_and_left
  -- Setoid.refl
  -- Duper.loob_hoist_proof
  -- Duper.not_of_eq_false
  -- Duper.forall_hoist_proof
  -- Duper.Skolem.some
  -- Duper.Skolem.spec
  -- Duper.bool_true_ne_false
  -- Duper.clausify_not_false
  -- Duper.rule10Theorem
  -- Duper.rule22Theorem
  -- Iff.symm
  -- eq_true
  -- Duper.false_neq_true
  -- Duper.rule2Theorem
  -- Duper.rule13SymTheorem
  -- of_eq_true
  -- Duper.true_neq_false
  -- And.symm
  -- congrArg
  -- Duper.rule6SymTheorem
  -- Duper.prop_false_ne_true
  -- Duper.c2_soundness
  -- congrFun
  -- Duper.rule11SymTheorem
  -- Nat
  -- outParam
  -- HAdd
  -- HAdd.hAdd
  -- Add
  -- instHAdd
  -- instAddNat
  -- Nat.add_assoc
  -- Duper.rule11Theorem
  -- Subtype
  -- Subtype.val
  -- Subtype.eq
  -- Iff.refl
  -- optParam
  -- sorryAx
  -- Iff.rfl
  -- Duper.rule2SymTheorem
  -- Duper.rule16Theorem
  -- Ne.elim
  -- Duper.equality_factoring_soundness3
  -- Duper.equality_factoring_soundness1
  -- Duper.rule1Theorem
  -- Duper.clausify_imp_false_right
  -- Duper.clausify_or_false_left
  -- Subsingleton
  -- Subsingleton.elim
  -- Duper.bool_hoist_proof
  -- Duper.rule19Theorem
  -- TPTP.iota
  -- LE
  -- LE.le
  -- instLENat
  -- LT.lt
  -- instLTNat
  -- OfNat
  -- OfNat.ofNat
  -- instOfNatNat
  -- HSub
  -- HSub.hSub
  -- Sub
  -- instHSub
  -- instSubNat
  -- Nat.sub.elim
  -- false_ne_true
  -- Acc
  -- Acc.below
  -- Acc.brecOn
  -- Duper.rule10SymTheorem
  -- Nonempty
  -- Duper.nonempty_of_forall_eq_false
  -- Duper.rule8Theorem
  -- Duper.rule23Theorem
  -- Or.symm
  -- Duper.rule4SymTheorem
  -- Duper.false_ne_true
  -- Duper.rule9SymTheorem
  -- Duper.rule9Theorem
  -- Duper.rule24Theorem
  -- Eq.symm
  -- Duper.rule4Theorem
  -- Or.elim
  -- Duper.fluid_loob_hoist_proof
  -- Duper.rule13Theorem
  -- Duper.ne_hoist_proof
  -- nonempty_of_exists
  -- Duper.clausify_prop_inequality2
  -- Duper.clausify_forall
  -- Duper.rule7Theorem
  -- Duper.rule18Theorem
  -- Exists.elim
  -- Duper.clausify_imp_false_left
  -- Duper.clausify_or
  -- Ne.symm
  -- Bool.of_not_eq_false
  -- Duper.rule3SymTheorem
  -- Duper.clausify_iff2
  -- Duper.rule17Theorem
  -- true_ne_false
  -- Duper.clausify_iff1
  -- Duper.clausify_exists_false
  -- Duper.clausify_not_iff1
  -- Duper.fluid_bool_hoist_proof
  -- Duper.nonempty_of_exists
  -- Duper.clausify_not_iff2
  -- Duper.equality_factoring_soundness2
  -- Nat.le
  -- Nat.le.below
  -- Nat.le.brecOn
def restoreCoreM : CoreM Unit := do
  let mut env ← getEnv
  if let none := env.find? `Eq then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Eq, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Not then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Not, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `True then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `True, levelParams := [], type := Expr.sort (Level.zero), isUnsafe := false})
  if let none := env.find? `False then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `False, levelParams := [], type := Expr.sort (Level.zero), isUnsafe := false})
  if let none := env.find? `Duper.clausify_not then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_not, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Exists then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Exists, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Or then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Or, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.exists_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.exists_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 0) (Expr.app (Expr.app (Expr.const `Exists [Level.param `u_1]) (Expr.bvar 3)) (Expr.lam `_ (Expr.bvar 3) (Expr.app (Expr.bvar 3) (Expr.bvar 0)) BinderInfo.default))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 1) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.bvar 3) (Expr.bvar 2))) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `And then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `And, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_and_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_and_false, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule20Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule20Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.app (Expr.const `Not []) (Expr.bvar 1)) BinderInfo.default)) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.c1_soundness then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.c1_soundness, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `HEq then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HEq, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `HEq.ndrec then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HEq.ndrec, levelParams := [`u1, `u2], type := Expr.forallE `_ (Expr.sort (Level.param `u2)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.param `u2)) (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.param `u1)) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.bvar 0) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.forallE `_ (Expr.sort (Level.param `u2)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HEq [Level.param `u2]) (Expr.bvar 5)) (Expr.bvar 4)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.bvar 4) (Expr.bvar 2)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_or_false_right then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_or_false_right, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_imp then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_imp, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 1) (Expr.bvar 1) BinderInfo.default)) (Expr.const `True [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.true_ne_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.true_ne_false, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `True [])) (Expr.const `False [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Ne then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Ne, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_prop_inequality1 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_prop_inequality1, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Bool then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Bool, levelParams := [], type := Expr.sort (Level.succ (Level.zero)), isUnsafe := false})
  if let none := env.find? `Bool.false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Bool.false, levelParams := [], type := Expr.const `Bool [], isUnsafe := false})
  if let none := env.find? `Bool.true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Bool.true, levelParams := [], type := Expr.const `Bool [], isUnsafe := false})
  if let none := env.find? `Duper.bool_false_ne_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.bool_false_ne_true, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.const `Bool [])) (Expr.const `Bool.false [])) (Expr.const `Bool.true [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Iff then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Iff, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule28Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule28Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.bvar 0))) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule6Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule6Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 0)) (Expr.const `True []))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule15Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule15Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.app (Expr.const `Not []) (Expr.bvar 0)))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.prop_true_ne_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.prop_true_ne_false, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `True [])) (Expr.const `False [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Setoid then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Setoid, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.sort (Level.max (Level.succ (Level.zero)) (Level.param `u))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `HasEquiv then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HasEquiv, levelParams := [`u, `v], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.sort (Level.max (Level.param `u) (Level.succ (Level.param `v)))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `HasEquiv.Equiv then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HasEquiv.Equiv, levelParams := [`u, `v], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.app (Expr.const `HasEquiv [Level.param `u, Level.param `v]) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.sort (Level.param `v)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `instHasEquiv then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `instHasEquiv, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.app (Expr.const `Setoid [Level.param `u]) (Expr.bvar 0)) (Expr.app (Expr.const `HasEquiv [Level.param `u, Level.zero]) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Setoid.symm then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Setoid.symm, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.app (Expr.const `Setoid [Level.param `u]) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HasEquiv.Equiv [Level.param `u, Level.zero]) (Expr.bvar 3)) (Expr.app (Expr.app (Expr.const `instHasEquiv [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 2))) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HasEquiv.Equiv [Level.param `u, Level.zero]) (Expr.bvar 4)) (Expr.app (Expr.app (Expr.const `instHasEquiv [Level.param `u]) (Expr.bvar 4)) (Expr.bvar 3))) (Expr.bvar 1)) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.of_not_eq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.of_not_eq_false, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) (Expr.const `False [])) (Expr.bvar 1) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `HEq.elim then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HEq.elim, levelParams := [`u, `v], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 1) (Expr.sort (Level.param `v)) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HEq [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 3)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.app (Expr.bvar 2) (Expr.bvar 3)) (Expr.app (Expr.bvar 3) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule12Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule12Theorem, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.bvar 0) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.param `u_1]) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.bvar 0))) (Expr.const `False [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule21Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule21Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.app (Expr.const `Not []) (Expr.bvar 0)) (Expr.bvar 1) BinderInfo.default)) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule3Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule3Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 0)) (Expr.const `True []))) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.exists_of_forall_eq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.exists_of_forall_eq_false, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default)) (Expr.const `False [])) (Expr.app (Expr.app (Expr.const `Exists [Level.param `u_1]) (Expr.bvar 2)) (Expr.lam `_ (Expr.bvar 2) (Expr.app (Expr.const `Not []) (Expr.app (Expr.bvar 2) (Expr.bvar 0))) BinderInfo.default)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.equality_factoring_soundness4 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.equality_factoring_soundness4, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 1)) (Expr.bvar 2))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `List then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `List, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.sort (Level.succ (Level.param `u))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `List.Mem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `List.Mem, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 1)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `List.Mem.below then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `List.Mem.below, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 1)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `List.Mem [Level.param `u]) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 2)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `List.Mem [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `List.Mem.brecOn then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `List.Mem.brecOn, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 1)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `List.Mem [Level.param `u]) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 2)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `List.Mem [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 4)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `List.Mem [Level.param `u]) (Expr.bvar 5)) (Expr.bvar 4)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `List.Mem.below [Level.param `u]) (Expr.bvar 6)) (Expr.bvar 5)) (Expr.bvar 4)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.bvar 5) (Expr.bvar 2)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) (Expr.app (Expr.app (Expr.bvar 3) (Expr.bvar 2)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule14Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule14Theorem, levelParams := [], type := Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.const `True []))) (Expr.const `False []), isUnsafe := false})
  if let none := env.find? `HEq.symm then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HEq.symm, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HEq [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 1)) (Expr.bvar 2)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HEq [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 1)) (Expr.bvar 4)) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.eq_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.eq_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 0) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u_1]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 1) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u_1]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 2))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `LT then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `LT, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.sort (Level.succ (Level.param `u))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `List.lt then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `List.lt, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.app (Expr.const `LT [Level.param `u]) (Expr.bvar 0)) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 1)) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 2)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `List.lt.below then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `List.lt.below, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.app (Expr.const `LT [Level.param `u]) (Expr.bvar 0)) (Expr.forallE `_ (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 1)) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 2)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `List.lt [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 2)) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 3)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `List.lt [Level.param `u]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `List.lt.brecOn then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `List.lt.brecOn, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.app (Expr.const `LT [Level.param `u]) (Expr.bvar 0)) (Expr.forallE `_ (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 1)) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 2)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `List.lt [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 2)) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 3)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `List.lt [Level.param `u]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 5)) (Expr.forallE `_ (Expr.app (Expr.const `List [Level.param `u]) (Expr.bvar 6)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `List.lt [Level.param `u]) (Expr.bvar 7)) (Expr.bvar 6)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `List.lt.below [Level.param `u]) (Expr.bvar 8)) (Expr.bvar 7)) (Expr.bvar 6)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.app (Expr.bvar 7) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) (Expr.app (Expr.app (Expr.app (Expr.bvar 4) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_and_right then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_and_right, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule5Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule5Theorem, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.bvar 0) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u_1]) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.bvar 0))) (Expr.const `True [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_and_left then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_and_left, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Setoid.refl then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Setoid.refl, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.app (Expr.const `Setoid [Level.param `u]) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 1) (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HasEquiv.Equiv [Level.param `u, Level.zero]) (Expr.bvar 2)) (Expr.app (Expr.app (Expr.const `instHasEquiv [Level.param `u]) (Expr.bvar 2)) (Expr.bvar 1))) (Expr.bvar 0)) (Expr.bvar 0)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.loob_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.loob_hoist_proof, levelParams := [], type := Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.bvar 1) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 2) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.not_of_eq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.not_of_eq_false, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 0)) (Expr.const `False [])) (Expr.app (Expr.const `Not []) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.forall_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.forall_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 3) (Expr.app (Expr.bvar 3) (Expr.bvar 0)) BinderInfo.default)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 1) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.bvar 3) (Expr.bvar 2))) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.Skolem.some then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.Skolem.some, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 1) (Expr.bvar 2) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.Skolem.spec then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.Skolem.spec, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Exists [Level.param `u_1]) (Expr.bvar 2)) (Expr.lam `_ (Expr.bvar 2) (Expr.app (Expr.bvar 2) (Expr.bvar 0)) BinderInfo.default)) (Expr.app (Expr.bvar 2) (Expr.app (Expr.app (Expr.app (Expr.const `Duper.Skolem.some [Level.param `u_1]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.bool_true_ne_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.bool_true_ne_false, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.const `Bool [])) (Expr.const `Bool.true [])) (Expr.const `Bool.false [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_not_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_not_false, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule10Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule10Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 0)) (Expr.const `True []))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule22Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule22Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.bvar 1) BinderInfo.default)) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Iff.symm then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Iff.symm, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `eq_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `eq_true, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.bvar 0) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.false_neq_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.false_neq_true, levelParams := [], type := Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `False [])) (Expr.const `True []), isUnsafe := false})
  if let none := env.find? `Duper.rule2Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule2Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) (Expr.bvar 0))) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule13SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule13SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `False [])) (Expr.bvar 0))) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `of_eq_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `of_eq_true, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 0)) (Expr.const `True [])) (Expr.bvar 1) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.true_neq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.true_neq_false, levelParams := [], type := Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `True [])) (Expr.const `False []), isUnsafe := false})
  if let none := env.find? `And.symm then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `And.symm, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 1)) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `congrArg then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `congrArg, levelParams := [`u, `v], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.sort (Level.param `v)) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 3) (Expr.bvar 3) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u]) (Expr.bvar 4)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `v]) (Expr.bvar 4)) (Expr.app (Expr.bvar 1) (Expr.bvar 3))) (Expr.app (Expr.bvar 1) (Expr.bvar 2))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule6SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule6SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `True [])) (Expr.bvar 0))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.prop_false_ne_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.prop_false_ne_true, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `False [])) (Expr.const `True [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.c2_soundness then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.c2_soundness, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `congrFun then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `congrFun, levelParams := [`u, `v], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.param `v)) BinderInfo.default) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 2) (Expr.app (Expr.bvar 2) (Expr.bvar 0)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.imax (Level.param `u) (Level.param `v)]) (Expr.forallE `_ (Expr.bvar 3) (Expr.app (Expr.bvar 3) (Expr.bvar 0)) BinderInfo.default)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 4) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `v]) (Expr.app (Expr.bvar 4) (Expr.bvar 0))) (Expr.app (Expr.bvar 3) (Expr.bvar 0))) (Expr.app (Expr.bvar 2) (Expr.bvar 0))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule11SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule11SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.const `False [])) (Expr.bvar 0))) (Expr.const `False [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Nat then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Nat, levelParams := [], type := Expr.sort (Level.succ (Level.zero)), isUnsafe := false})
  if let none := env.find? `outParam then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `outParam, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.sort (Level.param `u)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `HAdd then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HAdd, levelParams := [`u, `v, `w], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.sort (Level.succ (Level.param `v))) (Expr.forallE `_ (Expr.app (Expr.const `outParam [Level.succ (Level.succ (Level.param `w))]) (Expr.sort (Level.succ (Level.param `w)))) (Expr.sort (Level.max (Level.max (Level.succ (Level.param `u)) (Level.succ (Level.param `v))) (Level.succ (Level.param `w)))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `HAdd.hAdd then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HAdd.hAdd, levelParams := [`u, `v, `w], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.sort (Level.succ (Level.param `v))) (Expr.forallE `_ (Expr.sort (Level.succ (Level.param `w))) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `HAdd [Level.param `u, Level.param `v, Level.param `w]) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 3) (Expr.forallE `_ (Expr.bvar 3) (Expr.bvar 3) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Add then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Add, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.sort (Level.succ (Level.param `u))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `instHAdd then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `instHAdd, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u_1))) (Expr.forallE `_ (Expr.app (Expr.const `Add [Level.param `u_1]) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.app (Expr.const `HAdd [Level.param `u_1, Level.param `u_1, Level.param `u_1]) (Expr.bvar 1)) (Expr.bvar 1)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `instAddNat then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `instAddNat, levelParams := [], type := Expr.app (Expr.const `Add [Level.zero]) (Expr.const `Nat []), isUnsafe := false})
  if let none := env.find? `Nat.add_assoc then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Nat.add_assoc, levelParams := [], type := Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.const `Nat []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.const `Nat [])) (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HAdd.hAdd [Level.zero, Level.zero, Level.zero]) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.app (Expr.app (Expr.const `instHAdd [Level.zero]) (Expr.const `Nat [])) (Expr.const `instAddNat []))) (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HAdd.hAdd [Level.zero, Level.zero, Level.zero]) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.app (Expr.app (Expr.const `instHAdd [Level.zero]) (Expr.const `Nat [])) (Expr.const `instAddNat []))) (Expr.bvar 2)) (Expr.bvar 1))) (Expr.bvar 0))) (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HAdd.hAdd [Level.zero, Level.zero, Level.zero]) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.app (Expr.app (Expr.const `instHAdd [Level.zero]) (Expr.const `Nat [])) (Expr.const `instAddNat []))) (Expr.bvar 2)) (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HAdd.hAdd [Level.zero, Level.zero, Level.zero]) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.app (Expr.app (Expr.const `instHAdd [Level.zero]) (Expr.const `Nat [])) (Expr.const `instAddNat []))) (Expr.bvar 1)) (Expr.bvar 0)))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule11Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule11Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 0)) (Expr.const `False []))) (Expr.const `False [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Subtype then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Subtype, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.sort (Level.max (Level.succ (Level.zero)) (Level.param `u))) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Subtype.val then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Subtype.val, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Subtype [Level.param `u]) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.bvar 2) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Subtype.eq then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Subtype.eq, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Subtype [Level.succ (Level.param `u)]) (Expr.bvar 1)) (Expr.lam `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Subtype [Level.succ (Level.param `u)]) (Expr.bvar 2)) (Expr.lam `_ (Expr.bvar 2) (Expr.app (Expr.bvar 2) (Expr.bvar 0)) BinderInfo.default)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.param `u)]) (Expr.bvar 3)) (Expr.app (Expr.app (Expr.app (Expr.const `Subtype.val [Level.succ (Level.param `u)]) (Expr.bvar 3)) (Expr.lam `_ (Expr.bvar 3) (Expr.app (Expr.bvar 3) (Expr.bvar 0)) BinderInfo.default)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.app (Expr.const `Subtype.val [Level.succ (Level.param `u)]) (Expr.bvar 3)) (Expr.lam `_ (Expr.bvar 3) (Expr.app (Expr.bvar 3) (Expr.bvar 0)) BinderInfo.default)) (Expr.bvar 0))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.param `u)]) (Expr.app (Expr.app (Expr.const `Subtype [Level.succ (Level.param `u)]) (Expr.bvar 4)) (Expr.lam `_ (Expr.bvar 4) (Expr.app (Expr.bvar 4) (Expr.bvar 0)) BinderInfo.default))) (Expr.bvar 2)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Iff.refl then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Iff.refl, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 0)) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `optParam then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `optParam, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.param `u)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `sorryAx then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `sorryAx, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `optParam [Level.succ (Level.zero)]) (Expr.const `Bool [])) (Expr.const `Bool.false [])) (Expr.bvar 1) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Iff.rfl then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Iff.rfl, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 0)) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule2SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule2SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 0)) (Expr.app (Expr.const `Not []) (Expr.bvar 0)))) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule16Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule16Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.const `True []) (Expr.bvar 1) BinderInfo.default)) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Ne.elim then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Ne.elim, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.param `u]) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.const `False []) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.equality_factoring_soundness3 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.equality_factoring_soundness3, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 2)) (Expr.bvar 1))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.equality_factoring_soundness1 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.equality_factoring_soundness1, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 2)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 1))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule1Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule1Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 0)) (Expr.bvar 0))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_imp_false_right then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_imp_false_right, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 1) (Expr.bvar 1) BinderInfo.default)) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_or_false_left then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_or_false_left, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Subsingleton then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Subsingleton, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.sort (Level.zero)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Subsingleton.elim then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Subsingleton.elim, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.app (Expr.const `Subsingleton [Level.param `u]) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 1)) (Expr.bvar 0)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.bool_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.bool_hoist_proof, levelParams := [], type := Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.bvar 1) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 2) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule19Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule19Theorem, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.const `True []) BinderInfo.default)) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `TPTP.iota then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `TPTP.iota, levelParams := [], type := Expr.sort (Level.succ (Level.zero)), isUnsafe := false})
  if let none := env.find? `LE then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `LE, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.sort (Level.succ (Level.param `u))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `LE.le then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `LE.le, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.app (Expr.const `LE [Level.param `u]) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `instLENat then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `instLENat, levelParams := [], type := Expr.app (Expr.const `LE [Level.zero]) (Expr.const `Nat []), isUnsafe := false})
  if let none := env.find? `LT.lt then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `LT.lt, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.app (Expr.const `LT [Level.param `u]) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `instLTNat then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `instLTNat, levelParams := [], type := Expr.app (Expr.const `LT [Level.zero]) (Expr.const `Nat []), isUnsafe := false})
  if let none := env.find? `OfNat then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `OfNat, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.const `Nat []) (Expr.sort (Level.succ (Level.param `u))) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `OfNat.ofNat then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `OfNat.ofNat, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `OfNat [Level.param `u]) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.bvar 2) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `instOfNatNat then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `instOfNatNat, levelParams := [], type := Expr.forallE `_ (Expr.const `Nat []) (Expr.app (Expr.app (Expr.const `OfNat [Level.zero]) (Expr.const `Nat [])) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `HSub then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HSub, levelParams := [`u, `v, `w], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.sort (Level.succ (Level.param `v))) (Expr.forallE `_ (Expr.app (Expr.const `outParam [Level.succ (Level.succ (Level.param `w))]) (Expr.sort (Level.succ (Level.param `w)))) (Expr.sort (Level.max (Level.max (Level.succ (Level.param `u)) (Level.succ (Level.param `v))) (Level.succ (Level.param `w)))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `HSub.hSub then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HSub.hSub, levelParams := [`u, `v, `w], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.sort (Level.succ (Level.param `v))) (Expr.forallE `_ (Expr.sort (Level.succ (Level.param `w))) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `HSub [Level.param `u, Level.param `v, Level.param `w]) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 3) (Expr.forallE `_ (Expr.bvar 3) (Expr.bvar 3) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Sub then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Sub, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.sort (Level.succ (Level.param `u))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `instHSub then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `instHSub, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u_1))) (Expr.forallE `_ (Expr.app (Expr.const `Sub [Level.param `u_1]) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.app (Expr.const `HSub [Level.param `u_1, Level.param `u_1, Level.param `u_1]) (Expr.bvar 1)) (Expr.bvar 1)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `instSubNat then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `instSubNat, levelParams := [], type := Expr.app (Expr.const `Sub [Level.zero]) (Expr.const `Nat []), isUnsafe := false})
  if let none := env.find? `Nat.sub.elim then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Nat.sub.elim, levelParams := [], type := Expr.forallE `_ (Expr.forallE `_ (Expr.const `Nat []) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `LE.le [Level.zero]) (Expr.const `Nat [])) (Expr.const `instLENat [])) (Expr.bvar 0)) (Expr.bvar 1)) (Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.const `Nat [])) (Expr.bvar 3)) (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HAdd.hAdd [Level.zero, Level.zero, Level.zero]) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.app (Expr.app (Expr.const `instHAdd [Level.zero]) (Expr.const `Nat [])) (Expr.const `instAddNat []))) (Expr.bvar 2)) (Expr.bvar 0))) (Expr.app (Expr.bvar 5) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `LT.lt [Level.zero]) (Expr.const `Nat [])) (Expr.const `instLTNat [])) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.app (Expr.bvar 4) (Expr.app (Expr.app (Expr.app (Expr.const `OfNat.ofNat [Level.zero]) (Expr.const `Nat [])) (Expr.lit (Literal.natVal 0))) (Expr.app (Expr.const `instOfNatNat []) (Expr.lit (Literal.natVal 0))))) BinderInfo.default) (Expr.app (Expr.bvar 4) (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HSub.hSub [Level.zero, Level.zero, Level.zero]) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.const `Nat [])) (Expr.app (Expr.app (Expr.const `instHSub [Level.zero]) (Expr.const `Nat [])) (Expr.const `instSubNat []))) (Expr.bvar 3)) (Expr.bvar 2))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `false_ne_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `false_ne_true, levelParams := [], type := Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `False [])) (Expr.const `True []), isUnsafe := false})
  if let none := env.find? `Acc then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Acc, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 1) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Acc.below then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Acc.below, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Acc [Level.param `u]) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Acc [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Acc.brecOn then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Acc.brecOn, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Acc [Level.param `u]) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Acc [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 4) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Acc [Level.param `u]) (Expr.bvar 5)) (Expr.bvar 4)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `Acc.below [Level.param `u]) (Expr.bvar 6)) (Expr.bvar 5)) (Expr.bvar 4)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.bvar 5) (Expr.bvar 2)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) (Expr.app (Expr.app (Expr.bvar 3) (Expr.bvar 2)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule10SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule10SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.const `True [])) (Expr.bvar 0))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Nonempty then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Nonempty, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.sort (Level.zero)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.nonempty_of_forall_eq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.nonempty_of_forall_eq_false, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default)) (Expr.const `False [])) (Expr.app (Expr.const `Nonempty [Level.param `u_1]) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule8Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule8Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 0)) (Expr.bvar 0))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule23Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule23Theorem, levelParams := [], type := Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default)) (Expr.app (Expr.app (Expr.const `And []) (Expr.app (Expr.bvar 0) (Expr.const `True []))) (Expr.app (Expr.bvar 0) (Expr.const `False [])))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Or.symm then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Or.symm, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 1)) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule4SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule4SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.const `False [])) (Expr.bvar 0))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.false_ne_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.false_ne_true, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `False [])) (Expr.const `True [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule9SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule9SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 0)) (Expr.app (Expr.const `Not []) (Expr.bvar 0)))) (Expr.const `False [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule9Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule9Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) (Expr.bvar 0))) (Expr.const `False [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule24Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule24Theorem, levelParams := [], type := Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Exists [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.lam `_ (Expr.sort (Level.zero)) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 0) (Expr.const `True []))) (Expr.app (Expr.bvar 0) (Expr.const `False [])))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Eq.symm then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Eq.symm, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u]) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 1)) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule4Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule4Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 0)) (Expr.const `False []))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Or.elim then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Or.elim, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 3) (Expr.bvar 2) BinderInfo.default) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 3) (Expr.bvar 3) BinderInfo.default) (Expr.bvar 3) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.fluid_loob_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.fluid_loob_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.bvar 3) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 2) (Expr.app (Expr.bvar 0) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 3) (Expr.app (Expr.bvar 1) (Expr.const `True [])))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule13Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule13Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 0)) (Expr.const `False []))) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.ne_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.ne_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 0) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.param `u_1]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 1) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u_1]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 2))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `nonempty_of_exists then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `nonempty_of_exists, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Exists [Level.param `u]) (Expr.bvar 1)) (Expr.lam `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default)) (Expr.app (Expr.const `Nonempty [Level.param `u]) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_prop_inequality2 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_prop_inequality2, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_forall then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_forall, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 2) (Expr.app (Expr.bvar 2) (Expr.bvar 0)) BinderInfo.default)) (Expr.const `True [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.bvar 2) (Expr.bvar 1))) (Expr.const `True [])) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule7Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule7Theorem, levelParams := [], type := Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.const `False []))) (Expr.const `True []), isUnsafe := false})
  if let none := env.find? `Duper.rule18Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule18Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.const `False []) BinderInfo.default)) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Exists.elim then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Exists.elim, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Exists [Level.param `u]) (Expr.bvar 2)) (Expr.lam `_ (Expr.bvar 2) (Expr.app (Expr.bvar 2) (Expr.bvar 0)) BinderInfo.default)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 3) (Expr.forallE `_ (Expr.app (Expr.bvar 3) (Expr.bvar 0)) (Expr.bvar 3) BinderInfo.default) BinderInfo.default) (Expr.bvar 2) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_imp_false_left then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_imp_false_left, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 1) (Expr.bvar 1) BinderInfo.default)) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_or then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_or, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Ne.symm then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Ne.symm, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.param `u]) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.param `u]) (Expr.bvar 3)) (Expr.bvar 1)) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Bool.of_not_eq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Bool.of_not_eq_false, levelParams := [], type := Expr.forallE `_ (Expr.const `Bool []) (Expr.forallE `_ (Expr.app (Expr.const `Not []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.const `Bool [])) (Expr.bvar 0)) (Expr.const `Bool.false []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.const `Bool [])) (Expr.bvar 1)) (Expr.const `Bool.true [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule3SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule3SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.const `True [])) (Expr.bvar 0))) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_iff2 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_iff2, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule17Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule17Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.const `False []) (Expr.bvar 1) BinderInfo.default)) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `true_ne_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `true_ne_false, levelParams := [], type := Expr.app (Expr.const `Not []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `True [])) (Expr.const `False [])), isUnsafe := false})
  if let none := env.find? `Duper.clausify_iff1 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_iff1, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_exists_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_exists_false, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Exists [Level.param `u_1]) (Expr.bvar 2)) (Expr.lam `_ (Expr.bvar 2) (Expr.app (Expr.bvar 2) (Expr.bvar 0)) BinderInfo.default))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.bvar 2) (Expr.bvar 1))) (Expr.const `False [])) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_not_iff1 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_not_iff1, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.fluid_bool_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.fluid_bool_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.bvar 3) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 2) (Expr.app (Expr.bvar 0) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 3) (Expr.app (Expr.bvar 1) (Expr.const `False [])))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.nonempty_of_exists then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.nonempty_of_exists, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Exists [Level.param `u_1]) (Expr.bvar 1)) (Expr.lam `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default))) (Expr.const `True [])) (Expr.app (Expr.const `Nonempty [Level.param `u_1]) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_not_iff2 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_not_iff2, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.equality_factoring_soundness2 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.equality_factoring_soundness2, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 2)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 1)) (Expr.bvar 3))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Nat.le then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Nat.le, levelParams := [], type := Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.const `Nat []) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Nat.le.below then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Nat.le.below, levelParams := [], type := Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Nat.le []) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Nat.le []) (Expr.bvar 2)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Nat.le.brecOn then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Nat.le.brecOn, levelParams := [], type := Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Nat.le []) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) (Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Nat.le []) (Expr.bvar 2)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.forallE `_ (Expr.const `Nat []) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Nat.le []) (Expr.bvar 4)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `Nat.le.below []) (Expr.bvar 5)) (Expr.bvar 4)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.bvar 5) (Expr.bvar 2)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) (Expr.app (Expr.app (Expr.bvar 3) (Expr.bvar 2)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  setEnv env