import Lean
import Std.Data.Array.Basic
import Auto.Lib.MonadUtils
import Auto.Lib.ExprExtra
import Auto.Lib.MetaExtra
import Auto.Translation.ReifM
import Auto.MathlibEmulator
import Auto.Embedding.LamChecker
import Auto.Embedding.LamInhReasoning
open Lean

initialize
  registerTraceClass `auto.buildChecker
  registerTraceClass `auto.lamReif.newChkStep
  registerTraceClass `auto.lamReif.printValuation
  registerTraceClass `auto.lamReif.printProofs
  registerTraceClass `auto.lamReif.printResult
  registerTraceClass `auto.lamReif.prep.def
  registerTraceClass `auto.lamReif.prep.printResult

namespace Auto.LamReif
open Embedding.Lam

/--
  We require that all instances of polymorphic constants,
    including `∀`, `∃`, `BitVec`, are turned into free variables
    before being sent to `LamReif.` Since propositional
    implication `→` has the same representation as `∀` in Lean `Expr`,
    we also require that they are turned into free variables.
  In this way, the expression that `LamReif` receives is an
    essentially higher-order term that can be reified directly.
-/
structure State where
  -- Maps previously reified type to their type atom index
  tyVarMap      : HashMap Expr Nat                := {}
  -- Maps previously reified expressions to their term atom index
  -- Whenever we encounter an atomic expression, we look up
  --   `varMap`. If it's already reified, then `varMap`
  --   tells us about its index. If it's not reified, insert
  --   it to `varMap`.
  varMap        : HashMap Expr Nat                := {}
  -- `tyVal` is the inverse of `tyVarMap`
  -- The `e : Expr` is the un-lifted valuation of the type atom
  -- The `lvl : level` is the sort level of `e`
  -- Let `u ← getU`. The interpretation of the sort atom would be
  --   `GLift.{lvl, u} e`
  tyVal         : Array (Expr × Level)            := #[]
  -- The `e : Expr` is the un-lifted counterpart of the interpretation of
  --   the term atom
  -- The `s : LamSort` is the λ sort of the atom
  -- The interpretation of the sort atom would be `s.upfunc e`
  varVal        : Array (Expr × LamSort)          := #[]
  -- lamILTy
  lamILTy       : Array LamSort                   := #[]
  -- Inverse of `lamILTy`
  isomTyMap     : HashMap LamSort Nat             := {}
  /-
    This hashmap contains assertions that have external (lean) proof
    · The key `t : LamTerm` is the corresponding λ term,
      where all `eq, ∀, ∃` are not of import version
    · The first `e : Expr` is the proof of the assertion
    · The second `t' : LamTerm` is `← mkImportVersion t`
    · The thrid `n : Nat` is the position of the assertion in the `ImportTable`
    · To be precise, we require that `e : GLift.down t.interp`

    This field also corresponds to the `ImportTable` in `LamChecker.lean`
  -/
  assertions    : HashMap LamTerm (Expr × LamTerm × Nat)   := {}
  /-
    This hashmap contains lamsorts who has external proof of inhabitation
  -/
  inhabitations : HashMap LamSort (Expr × Nat)    := {}
  -- Records the EvalResult and etoms generated by checksteps
  --   that produce etoms
  chkStepCache  : HashMap ChkStep (EvalResult × Array Nat) := {}
  -- The check step that produces a given etom
  etomChkStep   : HashMap Nat ChkStep             := {}
  -- We insert entries into `rTable` through two different ways
  -- 1. Calling `newChkStep`
  -- 2. Validness facts from the ImportTable are treated in `newAssertions`
  rst           : RTableStatus                    := {}
  -- `u` is the universe level that all constants will lift to
  -- Something about the universes level `u`
  -- Suppose `u ← getU`
  -- · `tyVal : Nat → Type u`
  -- · `LamValuation.{u}`
  -- · All the `GLift/GLift.up/GLift.down` has level parameter list `[?, u]`
  u             : Level
deriving Inhabited

abbrev ReifM := StateRefT State Reif.ReifM

@[inline] def ReifM.run' (x : ReifM α) (s : State) := Prod.fst <$> x.run s

#genMonadState ReifM

def getRTable : ReifM (Array REntry) := do return (← getRst).rTable

def getRTableTree : ReifM (BinTree REntry) := do return (← getRst).rTableTree

def getMaxEVarSucc : ReifM Nat := do return (← getRst).maxEVarSucc

def getLamEVarTy : ReifM (Array LamSort) := do return (← getRst).lamEVarTy

def getLamEVarTyTree : ReifM (BinTree LamSort) := do return (← getRst).lamEVarTyTree

def getChkMap : ReifM (HashMap REntry ChkStep) := do return (← getRst).chkMap

def checkerStats : ReifM (Array (String × Nat)) := do
  return #[("tyVal", (← getTyVal).size), ("varVal", (← getVarVal).size),
           ("ilLamTy", (← getLamILTy).size), ("assertions", (← getAssertions).size),
           ("chkMap", (← getChkMap).size), ("RTable", (← getRTable).size)]

def printCheckerStats : ReifM Unit := do
  let stats := (← checkerStats).map (fun (s, n) => "  " ++ s ++ s!": {n}")
  let ss := #["Checker Statistics:"] ++ stats
  trace[auto.buildChecker] (String.intercalate "\n" ss.data)

def printValuation : ReifM Unit := do
  let tyVal ← getTyVal
  for ((e, lvl), idx) in tyVal.zipWithIndex do
    trace[auto.lamReif.printValuation] "Type Atom {idx} := {e} : {Expr.sort lvl}"
  let varVal ← getVarVal
  for ((e, s), idx) in varVal.zipWithIndex do
    trace[auto.lamReif.printValuation] "Term Atom {idx} : {toString s} := {e}"
  let lamEVarTy ← getLamEVarTy
  for (s, idx) in lamEVarTy.zipWithIndex do
    trace[auto.lamReif.printValuation] "Etom {idx} : {toString s}"
  let lamIl ← getLamILTy
  for (s, idx) in lamIl.zipWithIndex do
    trace[auto.lamReif.printValuation] "LamILTy {idx} := {s}"

def printProofs : ReifM Unit := do
  let chkMap ← getChkMap
  for re in (← getRTable) do
    if let .some cs := chkMap.find? re then
      let .some n := (← getRst).findPos? re
        | throwError "printProofs :: Unexpected error"
      let etoms :=
        match (← getChkStepCache).find? cs with
        | .some (_, arr) =>
          if arr.size == 0 then m!"" else m!" and produces etoms {arr.data}"
        | .none => m!""
      trace[auto.lamReif.printProofs] "{n} : ChkStep ⦗⦗{cs}⦘⦘ proves ⦗⦗{re}⦘⦘{etoms}"
    else
      match re with
      | .valid [] t =>
        let .some (expr, _, n) := (← getAssertions).find? t
          | throwError "printProofs :: Unable to find assertion associated with {t}"
        trace[auto.lamReif.printProofs] "{n} : External fact ⦗⦗{← Meta.inferType expr}⦘⦘ proves ⦗⦗{re}⦘⦘"
      | .nonempty s =>
        let .some (expr, n) := (← getInhabitations).find? s
          | throwError "printProofs :: Unable to find inhabitation fact associated with {s}"
        trace[auto.lamReif.printProofs] "{n} : Inhabitation fact ⦗⦗{← Meta.inferType expr}⦘⦘ proves ⦗⦗{re}⦘⦘"
      | _ => throwError "printProofs :: Unexpected entry {re}"

def sort2LamILTyIdx (s : LamSort) : ReifM Nat := do
  let isomTyMap ← getIsomTyMap
  match isomTyMap.find? s with
  | .some n => return n
  | .none =>
    let lamILTy ← getLamILTy
    let idx := lamILTy.size
    setLamILTy (lamILTy.push s)
    setIsomTyMap (isomTyMap.insert s idx)
    return idx

def lookupTyVal! (n : Nat) : ReifM (Expr × Level) := do
  if let .some r := (← getTyVal)[n]? then
    return r
  else
    throwError "lookupTyVal! :: Unknown type atom {n}"

/-- Lookup valuation of term atom -/
def lookupVarVal! (n : Nat) : ReifM (Expr × LamSort) := do
  if let .some r := (← getVarVal)[n]? then
    return r
  else
    throwError "lookupVarVal! :: Unknown term atom {n}"

def lookupLamILTy! (idx : Nat) : ReifM LamSort := do
  if let .some s := (← getLamILTy)[idx]? then
    return s
  else
    throwError "lookupLamILTy! :: Unknown index {idx}"

def lookupAssertion! (t : LamTerm) : ReifM (Expr × LamTerm × Nat) := do
  if let .some r := (← getAssertions).find? t then
    return r
  else
    throwError "lookupAssertion! :: Unknown assertion {t}"

def lookupRTable! (pos : Nat) : ReifM REntry := do
  if let .some r := (← getRTable).get? pos then
    return r
  else
    throwError "lookupRTable! :: Unknown REntry {pos}"

def lookupREntryPos! (re : REntry) : ReifM Nat := do
  match (← getRst).findPos? re with
  | .some n => return n
  | .none =>
    match re with
    | .valid [] t =>
      match (← getAssertions).find? t with
      | .some (_, _, n) => return n
      | .none => throwError "lookupREntryPos! :: Unknown REntry {re}"
    | .nonempty s =>
      match (← getInhabitations).find? s with
      | .some (_, n) => return n
      | .none => throwError "lookupREntryPos! :: Unknown REntry {re}"
    | _ => throwError "lookupREntryPos! :: Unknown REntry {re}"

inductive REntryProof where
  | chkStep      : ChkStep → REntryProof
  | inhabitation : Expr → LamSort → REntryProof
  | assertion    : Expr → LamTerm → REntryProof

def lookupREntryProof? (re : REntry) : ReifM (Option REntryProof) := do
  match (← getChkMap).find? re with
  | .some cs => return .some (.chkStep cs)
  | .none =>
    match re with
    | .valid [] t =>
      match (← getAssertions).find? t with
      | .some (e, t, _) => return .some (.assertion e t)
      | .none => return .none
    | .nonempty s =>
      match (← getInhabitations).find? s with
      | .some (e, _) => return .some (.inhabitation e s)
      | .none => return .none
    | _ => return .none

def lookupREntryProof! (re : REntry) : ReifM REntryProof := do
  match ← lookupREntryProof? re with
  | .some proof => return proof
  | .none => throwError "lookupREntryProof! :: Unknown REntry {re}"

def lookupLamEVarTy! (idx : Nat) : ReifM LamSort := do
  if let .some s := (← getLamEVarTy)[idx]? then
    return s
  else
    throwError "lookupLamEVarTy! :: Unknown etom {idx}"

def lookupChkStepEtom! (cs : ChkStep) : ReifM (Array Nat) := do
  if let .some (_, arr) := (← getChkStepCache).find? cs then
    return arr
  else
    throwError "lookupChkStepEtom! :: ChkStep {cs} did not produce new etom"

def lookupChkStepResult! (cs : ChkStep) : ReifM EvalResult := do
  if let .some (er, _) := (← getChkStepCache).find? cs then
    return er
  else
    throwError "lookupChkStepEtom! :: ChkStep {cs} did not produce new etom"

def lookupEtomChkStep! (eidx : Nat) : ReifM ChkStep := do
  if let .some c := (← getEtomChkStep).find? eidx then
    return c
  else
    throwError "lookupEtomChkStep! :: Unknown etom {eidx}"

/--
  This should only be used at the meta level, i.e. in code that will
    be evaluated during the execution of `auto`
-/
def getLamTyValAtMeta : ReifM LamTyVal := do
  let varVal ← getVarVal
  let varTy := varVal.map Prod.snd
  let lamILTy ← getLamILTy
  let lamEVarTy ← getLamEVarTy
  return ⟨fun n => varTy[n]?.getD (.base .prop),
          fun n => lamILTy[n]?.getD (.base .prop),
          fun n => (lamEVarTy.get? n).getD (.base .prop)⟩

def resolveLamBaseTermImport : LamBaseTerm → ReifM LamBaseTerm
| .eqI n      => do return .eq (← lookupLamILTy! n)
| .forallEI n => do return .forallE (← lookupLamILTy! n)
| .existEI n  => do return .existE (← lookupLamILTy! n)
| .iteI n     => do return .ite (← lookupLamILTy! n)
| t           => pure t

/-- Models `resolveImport` on the `meta` level -/
def resolveImport : LamTerm → ReifM LamTerm
| .atom n       => return .atom n
| .etom _       => throwError "resolveImport :: etom should not occur here"
| .base b       => return .base (← resolveLamBaseTermImport b)
| .bvar n       => return .bvar n
| .lam s t      => return .lam s (← resolveImport t)
| .app s fn arg => return .app s (← resolveImport fn) (← resolveImport arg)

/--
  This is the inverse of `resolveImport`
  · When importing external proof `H : α`, we will reify `α`
    into `t : LamTerm` using `reifTerm`. The `t` returned
    by `reifTerm` has `eq` for `Eq`, `forallE` for `∀`,
    `existE` for `∃` and `ite` for `Auto.Bool.ite'`
  · It's easy to see that `t.interp` will not be definitionally
    equal to `α` because `=, ∀, ∃, ite'` within `α` operates on the
    original domain, while `=, ∀, ∃, ite'` in `t.interp` operates on
    the lifted domain
  · Therefore, we need to turn `=, ∀, ∃, ite'` in `t` into import
    version to get `t'`, and design an appropriate `ilVal`,
    such that `GLift.down t'.interp` is definitionally equal to `α`
-/
def mkImportVersion : LamTerm → ReifM LamTerm
| .atom n => return (.atom n)
| .etom _ => throwError "mkImportVersion :: etom should not occur here"
| .base b =>
  match b with
  | .eq s      => return .base (.eqI (← sort2LamILTyIdx s))
  | .forallE s => return .base (.forallEI (← sort2LamILTyIdx s))
  | .existE s  => return .base (.existEI (← sort2LamILTyIdx s))
  | .ite s     => return .base (.iteI (← sort2LamILTyIdx s))
  | b => return .base b
| .bvar n => return (.bvar n)
| .lam s t => do
  return .lam s (← mkImportVersion t)
| .app s t₁ t₂ => do
  return .app s (← mkImportVersion t₁) (← mkImportVersion t₂)

/--
  A new `ChkStep`. `res` is the expected result of the `ChkStep`
  Returns:
  1. Whether the checkstep produces a new REntry
  2. The `EvalResult` of this checkstep
-/
def newChkStep (c : ChkStep) (res? : Option EvalResult) : ReifM (Bool × EvalResult) := do
  trace[auto.lamReif.newChkStep] "New ChkStep {c}"
  -- For an etom-producing checkstep, evaluating it
  --   twice may yield different results. So, we lookup
  --   `chkStepCache` to see whether this checkstep has
  --   been evaluated before
  if let .some (res, _) := (← getChkStepCache).find? c then
    return (false, res)
  let ltv ← getLamTyValAtMeta
  let res := c.eval ltv.lamVarTy ltv.lamILTy ⟨← getRTableTree, ← getMaxEVarSucc, ← getLamEVarTyTree⟩
  if let .some res' := res? then
    if res' != res then
      throwError "newChkStep :: Result {res} of ChkStep {c} does not match with expected {res'}"
  match res with
  | .fail => throwError "newChkStep :: Evaluation of ChkStep {c} produces `fail`"
  | .addEntry re =>
    -- If `re` is already provable, do nothing
    if let .some _ ← lookupREntryProof? re then
      return (false, res)
    setChkStepCache ((← getChkStepCache).insert c (res, #[]))
    setRst ((← getRst).addEntry c re)
  | .newEtomWithValid s lctx t =>
    let re : REntry := .valid lctx t
    -- If `re` is already provable, do nothing
    if let .some _ ← lookupREntryProof? re then
      return (false, res)
    let eidx ← getMaxEVarSucc
    setChkStepCache ((← getChkStepCache).insert c (res, #[eidx]))
    setEtomChkStep ((← getEtomChkStep).insert eidx c)
    setRst ((← getRst).newEtomWithValid c re s)
  return (true, res)

/-- Returns the position of the entry inside the `RTable` -/
def addREntryToRTable (re : REntry) : ReifM Nat := do
  let pos := (← getRTable).size
  setRst ((← getRst).push re)
  return pos

/--
  `ty` is a reified assumption. `∀, ∃` and `=` in `ty` are supposed to
    not be of the import version
  The type of `proof` is definitionally equal to `GLift.down (← mkImportVersion ty).interp`
  Returns the position of `ty` inside the `validTable` after inserting it
-/
def newAssertion (proof : Expr) (ty : LamTerm) : ReifM Unit := do
  -- Because of the way we `buildImportTableExpr`, we need to deduplicate facts
  if let .some _ ← lookupREntryProof? (.valid [] ty) then
    return
  let pos ← addREntryToRTable (.valid [] ty)
  -- This `mkImportVersion` must be called before we build the lval expression
  -- So it cannot be called on-the-fly in `buildImportTableExpr`
  let tyi ← mkImportVersion ty
  setAssertions ((← getAssertions).insert ty (proof, tyi, pos))

/--
  Returns `false` if `s` is subsumed by previous inhabited sorts
  Returns `true` if not
-/
def inhSubsumptionCheck (s : LamSort) : ReifM Bool := do
  if Inhabitation.trivialQuick s then
    return false
  let inhs := (← getRst).nonemptyMap
  for (s', _) in inhs.toArray do
    if Inhabitation.subsumeQuick s' s then
      return false
  return true

/-- The type of `inh` should be definitionally equal to `s.interpAsUnlifted` -/
def newInhabitation (inh : Expr) (s : LamSort) : ReifM Unit := do
  -- Because of the way we `buildImportTableExpr`, we need to deduplicate facts
  if !(← inhSubsumptionCheck s) then
    return
  let pos ← addREntryToRTable (.nonempty s)
  setInhabitations ((← getInhabitations).insert s (inh, pos))

/-
  Computes `upFunc` and `downFunc` between `s.interpAsUnlifted` and `s.interpAsLifted`
  · `upFunc` is such that `upFunc f` is equivalent to `f↑`
  · `downFunc` is such that `downFunc f↑` is equivalent to `f`
  Return type:
  · The first `Expr` is `upFunc`
  · The second `Expr` is `downFunc`
  · The third `Expr` is `s.interpAsUnlifted`
  · The fourth `Expr` is `s.interpAsLifted`
-/
open Embedding in
partial def updownFunc (s : LamSort) : ReifM (Expr × Expr × Expr × Expr) :=
  match s with
  | .atom n => do
    let (orig, lvl) ← lookupTyVal! n
    let up := Expr.app (.const ``GLift.up [lvl, (← getU)]) orig
    let down := Expr.app (.const ``GLift.down [lvl, (← getU)]) orig
    return (up, down, orig, Expr.app (.const ``GLift [lvl, ← getU]) orig)
  | .base b => do
    let u ← getU
    let lvl₁ := Level.succ .zero
    let lift₁ := Expr.app (.const ``GLift [lvl₁, u])
    let liftup₁ := Expr.app (.const ``GLift.up [lvl₁, u])
    let liftdown₁ := Expr.app (.const ``GLift.down [lvl₁, u])
    match b with
    | .prop =>
      let ty := Expr.sort .zero
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
    | .bool =>
      let ty := Expr.const ``Bool []
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
    | .nat =>
      let ty := Expr.const ``Nat []
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
    | .int =>
      let ty := Expr.const ``Int []
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
    | .isto0 p =>
      let ty :=
        match p with
        | .xH => Expr.const ``String []
        | .xO .xH => Expr.const ``Empty []
        | _   => Expr.const ``Empty []
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
    | .bv n =>
      let ty := Expr.app (.const ``Std.BitVec []) (.lit (.natVal n))
      return (liftup₁ ty, liftdown₁ ty, ty, lift₁ ty)
  | .func s₁ s₂ => do
    let (uf₁, df₁, ty₁, tyUp₁) ← updownFunc s₁
    let (uf₂, df₂, ty₂, tyUp₂) ← updownFunc s₂
    let fty := Expr.forallE `_ ty₁ ty₂ .default
    let ftyUp := Expr.forallE `_ tyUp₁ tyUp₂ .default
    let up := Expr.lam `_ fty (Expr.lam `_ tyUp₁ (.app uf₂ (.app (.bvar 1) (.app df₁ (.bvar 0)))) .default) .default
    let down := Expr.lam `_ ftyUp (Expr.lam `_ ty₁ (.app df₂ (.app (.bvar 1) (.app uf₁ (.bvar 0)))) .default) .default
    return (up, down, fty, ftyUp)

/--
  `(e, s)` is a pair from the `varVal` field of `LamReif.ReifM.State`
  Returns the lifted counterpart of `e`
-/
def varValInterp (e : Expr) (s : LamSort) : ReifM Expr := do
  let (up, _, _, _) ← updownFunc s
  return .app up e

section ILLifting

  open Embedding

  private def mkImportAux (s : LamSort) : ReifM (Expr × Expr × Expr × Expr × Level) := do
    let (upFunc, downFunc, ty, upTy) ← updownFunc s
    let sortOrig ← Expr.normalizeType (← Meta.inferType ty)
    let .sort uOrig := sortOrig
      | throwError "mkImportAux :: Unexpected sort {sortOrig} when processing sort {s}"
    return (upFunc, downFunc, ty, upTy, uOrig)

  set_option pp.universes true
  def mkIsomType (upFunc downFunc ty upTy : Expr) (uOrig : Level) : ReifM Expr := do
    let u ← getU
    let eq₁ : Expr := mkLambda `_ .default ty (mkAppN (.const ``Eq.refl [uOrig]) #[ty, .bvar 0])
    let eq₂ : Expr := mkLambda `_ .default upTy (mkAppN (.const ``Eq.refl [.succ u]) #[upTy, .bvar 0])
    let isomTy : Expr := mkAppN (.const ``IsomType.mk [uOrig, .succ u]) #[ty, upTy, upFunc, downFunc, eq₁, eq₂]
    return isomTy

  /-- Suppose `u ← getU`, this function returns a term of type `ILLift.{u} s.interpAsLifted` -/
  def mkImportingILLift (s : LamSort) := do
    let (upFunc, downFunc, ty, upTy, uOrig) ← mkImportAux s
    let isomTy ← mkIsomType upFunc downFunc ty upTy uOrig
    let ilLift := mkAppN (.const ``ILLift.ofIsomTy [uOrig, (← getU)]) #[ty, upTy, isomTy]
    return ilLift

end ILLifting

-- This section should only be used when exporting terms to external provers
section ExportUtils

  def exportError.ImpPolyLog :=
    "Import versions of polymorphic logical " ++
    "constants should have been eliminated"

  def collectLamSortAtoms : LamSort → HashSet Nat
  | .atom n => HashSet.empty.insert n
  | .base _ => HashSet.empty
  | .func a b => (collectLamSortAtoms a).insertMany (collectLamSortAtoms b)

  def collectLamSortsAtoms (ss : Array LamSort) : HashSet Nat :=
    ss.foldl (fun hs s => hs.insertMany (collectLamSortAtoms s)) HashSet.empty

  def collectLamSortBitVecLengths : LamSort → HashSet Nat
  | .base (.bv n) => HashSet.empty.insert n
  | .func a b => (collectLamSortBitVecLengths a).insertMany (collectLamSortBitVecLengths b)
  | _ => HashSet.empty

  def collectLamSortsBitVecLengths (ss : Array LamSort) : HashSet Nat :=
    ss.foldl (fun hs s => hs.insertMany (collectLamSortBitVecLengths s)) HashSet.empty

  /-- Collect type atoms in a LamBaseTerm -/
  def collectLamBaseTermAtoms (b : LamBaseTerm) : CoreM (HashSet Nat) := do
    let s? : Option LamSort ← (do
      match b with
      | .eqI _ => throwError ("collectAtoms :: " ++ exportError.ImpPolyLog)
      | .forallEI _ => throwError ("collectAtoms :: " ++ exportError.ImpPolyLog)
      | .existEI _ => throwError ("collectAtoms :: " ++ exportError.ImpPolyLog)
      | .iteI _ => throwError ("collectAtoms :: " ++ exportError.ImpPolyLog)
      | .eq s => return .some s
      | .forallE s => return .some s
      | .existE s => return .some s
      | .ite s => return .some s
      | _ => return none)
    if let .some s := s? then
      return collectLamSortAtoms s
    else
      return HashSet.empty

  /--
    The first hashset is the type atoms
    The second hashset is the term atoms
    The third hashset is the term etoms
    This function is called when we're trying to export terms
      from `λ` to external provers, e.g. Lean/Duper
    Therefore, we expect that `eqI, forallEI, existEI` and ``ite'`
      does not occur in the `LamTerm`
  -/
  def collectLamTermAtoms (lamVarTy : Array LamSort) (lamEVarTy : Array LamSort) :
    LamTerm → CoreM (HashSet Nat × HashSet Nat × HashSet Nat)
  | .atom n => do
    let .some s := lamVarTy[n]?
      | throwError "collectAtoms :: Unknown term atom {n}"
    return (collectLamSortAtoms s, HashSet.empty.insert n, HashSet.empty)
  | .etom n => do
    let .some s := lamEVarTy[n]?
      | throwError "collectAtoms :: Unknown etom {n}"
    return (collectLamSortAtoms s, HashSet.empty, HashSet.empty.insert n)
  | .base b => do
    return (← collectLamBaseTermAtoms b, HashSet.empty, HashSet.empty)
  | .bvar _ => pure (HashSet.empty, HashSet.empty, HashSet.empty)
  | .lam s t => do
    let (typeHs, termHs, etomHs) ← collectLamTermAtoms lamVarTy lamEVarTy t
    let sHs := collectLamSortAtoms s
    return (mergeHashSet typeHs sHs, termHs, etomHs)
  | .app _ t₁ t₂ => do
    let (typeHs₁, termHs₁, etomHs₁) ← collectLamTermAtoms lamVarTy lamEVarTy t₁
    let (typeHs₂, termHs₂, etomHs₂) ← collectLamTermAtoms lamVarTy lamEVarTy t₂
    return (mergeHashSet typeHs₁ typeHs₂,
            mergeHashSet termHs₁ termHs₂,
            mergeHashSet etomHs₁ etomHs₂)

  def collectLamTermsAtoms (lamVarTy : Array LamSort) (lamEVarTy : Array LamSort)
    (ts : Array LamTerm) : CoreM (HashSet Nat × HashSet Nat × HashSet Nat) :=
    ts.foldlM (fun (tyHs, aHs, eHs) t => do
      let (tyHs', aHs', eHs') ← collectLamTermAtoms lamVarTy lamEVarTy t
      return (mergeHashSet tyHs tyHs', mergeHashSet aHs aHs', mergeHashSet eHs eHs'))
      (HashSet.empty, HashSet.empty, HashSet.empty)

  def collectLamTermNatConsts : LamTerm → HashSet NatConst
  | .base (.ncst nc) => HashSet.empty.insert nc
  | .lam _ body => collectLamTermNatConsts body
  | .app _ fn arg => mergeHashSet (collectLamTermNatConsts fn) (collectLamTermNatConsts arg)
  | _ => HashSet.empty

  def collectLamTermsNatConsts (ts : Array LamTerm) : HashSet NatConst :=
    ts.foldl (fun hs t => mergeHashSet hs (collectLamTermNatConsts t)) HashSet.empty

  def collectLamTermIntConsts : LamTerm → HashSet IntConst
  | .base (.icst ic) => HashSet.empty.insert ic
  | .lam _ body => collectLamTermIntConsts body
  | .app _ fn arg => mergeHashSet (collectLamTermIntConsts fn) (collectLamTermIntConsts arg)
  | _ => HashSet.empty

  def collectLamTermsIntConsts (ts : Array LamTerm) : HashSet IntConst :=
    ts.foldl (fun hs t => mergeHashSet hs (collectLamTermIntConsts t)) HashSet.empty

  def collectLamTermStringConsts : LamTerm → HashSet StringConst
  | .base (.scst sc) => HashSet.empty.insert sc
  | .lam _ body => collectLamTermStringConsts body
  | .app _ fn arg => mergeHashSet (collectLamTermStringConsts fn) (collectLamTermStringConsts arg)
  | _ => HashSet.empty

  def collectLamTermsStringConsts (ts : Array LamTerm) : HashSet StringConst :=
    ts.foldl (fun hs t => mergeHashSet hs (collectLamTermStringConsts t)) HashSet.empty

  def collectLamTermBitvecs : LamTerm → HashSet BitVecConst
  | .base (.bvcst bvc) => HashSet.empty.insert bvc
  | .lam _ body => collectLamTermBitvecs body
  | .app _ fn arg => mergeHashSet (collectLamTermBitvecs fn) (collectLamTermBitvecs arg)
  | _ => HashSet.empty

  def collectLamTermsBitvecs (ts : Array LamTerm) : HashSet BitVecConst :=
    ts.foldl (fun hs t => mergeHashSet hs (collectLamTermBitvecs t)) HashSet.empty

  def collectLamTermIteSorts : LamTerm → HashSet LamSort
  | .base (.ite s) => HashSet.empty.insert s
  | .lam _ body => collectLamTermIteSorts body
  | .app _ fn arg => mergeHashSet (collectLamTermIteSorts fn) (collectLamTermIteSorts arg)
  | _ => HashSet.empty

  def collectLamTermsIteSorts (ts : Array LamTerm) : HashSet LamSort :=
    ts.foldl (fun hs t => mergeHashSet hs (collectLamTermIteSorts t)) HashSet.empty

end ExportUtils

-- Functions that operates on the checker table
section Checker

  def nonemptyOfAtom (n : Nat) : ReifM (Option REntry) := do
    let .some (_, s) := (← getVarVal).get? n
      | throwError "nonemptyOfAtom :: Index {n} out of bound"
    if !(← inhSubsumptionCheck s) then
      return .none
    let (_, .addEntry re) ← newChkStep (.n (.nonemptyOfAtom n)) (.some (.addEntry (.nonempty s)))
      | throwError "nonemptyOfAtom :: Unexpected evaluation result"
    return .some re

  def nonemptyOfEtom (n : Nat) : ReifM (Option REntry) := do
    let .some s := (← getLamEVarTy).get? n
      | throwError "nonemptyOfEtom :: Index {n} out of bound"
    if !(← inhSubsumptionCheck s) then
      return .none
    let (_, .addEntry re) ← newChkStep (.n (.nonemptyOfEtom n)) (.some (.addEntry (.nonempty s)))
      | throwError "nonemptyOfEtom :: Unexpected evaluation result"
    return .some re

  def validOfIntros (v : REntry) (idx : Nat) : ReifM REntry := do
    if idx == 0 then
      return v
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.l (.validOfIntros p idx)) .none
      | throwError "validOfIntros :: Unexpected evaluation result"
    return re

  def validOfIntroMost (v : REntry) : ReifM REntry := do
    let .valid _ t := v
      | throwError "validOfIntroMost :: Unexpected entry {v}"
    let mut idx := 0
    let mut t := t
    while true do
      match t.intro1? with
      | .some (_, t') =>
        idx := idx + 1
        t := t'
      | .none => break
    validOfIntros v idx

  def validOfReverts (v : REntry) (idx : Nat) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.l (.validOfReverts p idx)) .none
      | throwError "validOfReverts :: Unexpected evaluation result"
    return re

  def validOfRevertAll (v : REntry) : ReifM REntry := do
    let .valid lctx _ := v
      | throwError "validOfRevertAll :: Unexpected entry {v}"
    if lctx.length == 0 then
      return v
    validOfReverts v lctx.length

  def validOfAppend (v : REntry) (ex : Array LamSort) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.l (.validOfAppend p ex.toList)) .none
      | throwError "validOfAppend :: Unexpected evaluation result"
    return re

  def validOfPrepend (v : REntry) (ex : Array LamSort) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.l (.validOfPrepend p ex.toList)) .none
      | throwError "validOfPrepend :: Unexpected evaluation result"
    return re

  def validOfHeadBeta (v : REntry) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.c (.validOfHeadBeta p)) .none
      | throwError "validOfHeadBeta :: Unexpected evaluation result"
    return re

  def validOfHnf (v : REntry) : ReifM REntry := do
    let mut v := v
    while true do
      let .valid _ t := v
        | throwError "validOfHnf :: Unexpected entry {v}"
      if !t.isHeadBetaTarget then
        break
      v ← validOfHeadBeta v
    return v

  def validOfBetaBounded (v : REntry) (bound : Nat) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.c (.validOfBetaBounded p bound)) .none
      | throwError "validOfBetaBounded :: Unexpected evaluation result"
    return re

  def validOfBetaReduce (v : REntry) : ReifM REntry := do
    let .valid _ t := v
      | throwError "validOfBetaReduce :: Unexpected entry {v}"
    validOfBetaBounded v t.betaReduceHackyIdx

  def validOfExtensionalize (v : REntry) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.c (.validOfExtensionalize p)) .none
      | throwError "validOfExtensionalize :: Unexpected evaluation result"
    return re

  def validOfEqSymm (v : REntry) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.c (.validOfEqSymm p)) .none
      | throwError "validOfEqSymm :: Unexpected evaluation result"
    return re

  def validOfMp (vp : REntry) (vrw : REntry) : ReifM REntry := do
    let pp ← lookupREntryPos! vp
    let prw ← lookupREntryPos! vrw
    let (_, .addEntry re) ← newChkStep (.c (.validOfMp pp prw)) .none
      | throwError "validOfMp :: Unexpected evaluation result"
    return re

  def validOfMpAll (vp : REntry) (vrw : REntry) : ReifM REntry := do
    let pp ← lookupREntryPos! vp
    let prw ← lookupREntryPos! vrw
    let (_, .addEntry re) ← newChkStep (.c (.validOfMpAll pp prw)) .none
      | throwError "validOfMpAll :: Unexpected evaluation result"
    return re

  def validOfEtaExpand1At (v : REntry) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.ca (.validOfEtaExpand1At pv occ)) .none
      | throwError "validOfEtaExpand1At :: Unexpected evaluation result"
    return re

  def validOfEtaReduce1At (v : REntry) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.ca (.validOfEtaReduce1At pv occ)) .none
      | throwError "validOfEtaReduce1At :: Unexpected evaluation result"
    return re

  def validOfEtaExpandNAt (v : REntry) (n : Nat) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    if n == 0 then
      return v
    if n == 1 then
      return ← validOfEtaExpand1At v occ
    let (_, .addEntry re) ← newChkStep (.ca (.validOfEtaExpandNAt pv n occ)) .none
      | throwError "validOfEtaExpandNAt :: Unexpected evaluation result"
    return re

  def validOfEtaReduceNAt (v : REntry) (n : Nat) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    if n == 0 then
      return v
    if n == 1 then
      return ← validOfEtaReduce1At v occ
    let (_, .addEntry re) ← newChkStep (.ca (.validOfEtaReduceNAt pv n occ)) .none
      | throwError "validOfEtaReduceNAt :: Unexpected evaluation result"
    return re

  def validOfEtaExpandAt (v : REntry) (occ : List Bool) : ReifM REntry := do
    let .valid _ t := v
      | throwError "validOfEtaExpandAt :: Unexpected entry {v}"
    let .some (rty, _) := LamTerm.getPosWith occ (.base .prop) t
      | throwError "validOfEtaExpandAt :: {occ} is not a valid position of {t}"
    let n := rty.getArgTys.length
    validOfEtaExpandNAt v n occ

  def validOfEtaReduceAt (v : REntry) (occ : List Bool) : ReifM REntry := do
    let .valid _ t := v
      | throwError "validOfEtaReduceAt :: Unexpected entry {v}"
    let .some tocc := LamTerm.getPos occ t
      | throwError "validOfEtaReduceAt :: {occ} is not a valid position of {t}"
    let n := tocc.getLamTys.length
    validOfEtaReduceNAt v n occ

  def validOfExtensionalizeEqAt (v : REntry) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.ca (.validOfExtensionalizeEqAt pv occ)) .none
      | throwError "validOfExtensionalizeEqAt :: Unexpected evaluation result"
    return re

  def validOfExtensionalizeEqFNAt (v : REntry) (n : Nat) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.ca (.validOfExtensionalizeEqFNAt pv n occ)) .none
      | throwError "validOfExtensionalizeEqFNAt :: Unexpected evaluation result"
    return re

  def validOfIntensionalizeEqAt (v : REntry) (occ : List Bool) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.ca (.validOfIntensionalizeEqAt pv occ)) .none
      | throwError "validOfIntensionalizeEqAt :: Unexpected evaluation result"
    return re

  def validOfBVarLower (v : REntry) (n : REntry) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let pn ← lookupREntryPos! n
    let (_, .addEntry re) ← newChkStep (.i (.validOfBVarLower pv pn)) .none
      | throwError "validOfBVarLower :: Unexpected evaluation result"
    return re

  def validOfBVarLowers (v : REntry) (ns : Array REntry) : ReifM REntry := do
    let pv ← lookupREntryPos! v
    let pns ← ns.mapM lookupREntryPos!
    let (_, .addEntry re) ← newChkStep (.i (.validOfBVarLowers pv pns.data)) .none
      | throwError "validOfBVarLowers :: Unexpected evaluation result"
    return re

  /--
    Given `∀ (_ : s₀) (_ : s₁) ⋯ (_ : sₖ₋₁), body` and the fact
      that `s₀, s₁, ⋯, sₖ₋₁` are nonempty, return a proof of `body`
  -/
  def validOfElimForalls (v : REntry) (ns : Array REntry) : ReifM REntry := do
    let introed ← validOfIntros v ns.size
    validOfBVarLowers introed ns.reverse

  def validOfImp (v₁₂ : REntry) (v₁ : REntry) : ReifM REntry := do
    let p₁₂ ← lookupREntryPos! v₁₂
    let p₁ ← lookupREntryPos! v₁
    let (_, .addEntry re) ← newChkStep (.i (.validOfImp p₁₂ p₁)) .none
      | throwError "validOfImp :: Unexpected evaluation result"
    return re

  def validOfImps (impV : REntry) (hypVs : Array REntry) : ReifM REntry := do
    let imp ← lookupREntryPos! impV
    let ps ← hypVs.mapM lookupREntryPos!
    let (_, .addEntry re) ← newChkStep (.i (.validOfImps imp ps.data)) .none
      | throwError "validOfImps :: Unexpected evaluation result"
    return re

  /-- Repeated instantiation -/
  def validOfInstantiate (v : REntry) (args : Array LamTerm) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.i (.validOfInstantiate p args.data)) .none
      | throwError "validOfInstantiate :: Unexpected evaluation result"
    return re

  def validOfInstantiateRev (v : REntry) (args : Array LamTerm) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.i (.validOfInstantiateRev p args.data)) .none
      | throwError "validOfInstantiateRev :: Unexpected evaluation result"
    return re

  /--
    Given `∀ x₀ x₁ ⋯ xₖ₋₁, p` and `arg₀, arg₁, ⋯, argₖ₋₁`, return
      `p[x₀/arg₀, x₁/arg₁, ⋯, xₖ₋₁/argₖ₋₁]`
  -/
  def validOfInstantiateForall (v : REntry) (args : Array LamTerm) : ReifM REntry := do
    if args.size == 0 then
      return v
    let v ← validOfIntros v args.size
    validOfInstantiateRev v args

  def validOfAndLeft (v : REntry) (occ : List Bool) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.i (.validOfAndLeft p occ)) .none
      | throwError "validOfAndLeft :: Unexpected evaluation result"
    return re

  def validOfAndRight (v : REntry) (occ : List Bool) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.i (.validOfAndRight p occ)) .none
      | throwError "validOfAndRight :: Unexpected evaluation result"
    return re

  /-- Exhaustively decompose `∧` at position `occ` -/
  partial def decomposeAnd (v : REntry) (occ : List Bool) : ReifM (Array REntry) := do
    let .valid _ t := v
      | throwError "decomposeAnd :: Unexpected entry"
    if !(t.isSign true occ) then throwError "decomposeAnd :: {occ} is not a positive position of {t}"
    let .some sub := t.getPos occ
      | throwError "decomposeAnd :: Unexpected error"
    if sub.getAppFn == .base .and && sub.getAppArgs.length == 2 then
      let left ← validOfAndLeft v occ
      let right ← validOfAndRight v occ
      return (← decomposeAnd left occ).append (← decomposeAnd right occ)
    else
      return #[v]

  def boolFacts : ReifM REntry := do
    let (_, .addEntry re) ← newChkStep (.f .boolFacts) .none
      | throwError "boolFacts :: Unexpected evaluation result"
    return re

  def iteSpec (s : LamSort) : ReifM REntry := do
    let (_, .addEntry re) ← newChkStep (.f (.iteSpec s)) .none
      | throwError "iteSpec :: Unexpected evaluation result"
    return re

  def skolemize (exV : REntry) : ReifM REntry := do
    let eidx ← getMaxEVarSucc
    let ex ← lookupREntryPos! exV
    let (new?, .newEtomWithValid _ lctx t) ← newChkStep (.e (.skolemize ex)) .none
      | throwError "skolemize :: Unexpected evaluation result"
    if new? then
      let _ ← nonemptyOfEtom eidx
    return .valid lctx t

  -- TODO: To be replaced by complete clausification
  def skolemizeMostIntoForall (exV : REntry) : ReifM REntry := do
    let mut exV := exV
    while true do
      let .valid _ t := exV
        | throwError "skolemizeMostIntoForall :: Unexpected entry {exV}"
      if t.isMkForallE then
        exV ← validOfIntroMost exV
      let .valid _ t := exV
        | throwError "skolemizeMostIntoForall :: Unexpected entry {exV}"
      if t.isMkExistE then
        exV ← skolemize exV
        exV ← validOfHnf exV
      else
        break
    return exV

  def define (t : LamTerm) : ReifM REntry := do
    let eidx ← getMaxEVarSucc
    let (new?, .newEtomWithValid _ [] t) ← newChkStep (.e (.define t)) .none
      | throwError "define :: Unexpected evaluation result"
    if new? then
      let _ ← nonemptyOfEtom eidx
    return .valid [] t

  def validOfPrepConv (pc : PrepConvStep) (v : REntry) (occ : List Bool) : ReifM REntry := do
    let p ← lookupREntryPos! v
    let (_, .addEntry re) ← newChkStep (.p pc p occ) .none
      | throwError "validOfPrepConv :: Unexpected evaluation result"
    return re

end Checker

section CheckerUtils

  /--
    `.bvar i` will be turned into `.bvar map[i]`
    It is required that the size of `rmap` is equal to the length of local context
  -/
  def reorderLCtx (v : REntry) (rmap : Array Nat) : ReifM REntry := do
    let .valid lctx _ := v
      | throwError "reorderLCtx :: Unexpected entry {v}"
    let lsize := lctx.length
    if rmap.size != lsize then
      throwError "reorderLCtx :: Length of lctx does not equal size of reorder map"
    let mut ex : Array LamSort := rmap.map (fun _ => .atom 0)
    let mut argBVarIdx : Array Nat := #[]
    for (s, i) in (Array.mk lctx).zipWithIndex do
      let .some i' := rmap[i]?
        | throwError "reorderLCtx :: Does not know where does `.bvar i` map to"
      if i' >= lsize then
        throwError "reorderLCtx :: Index {i'} out of bound {lsize}"
      ex := ex.set! i' s
      argBVarIdx := argBVarIdx.push (lsize - i - 1 + i')
    let v ← validOfAppend v ex
    validOfInstantiate v (argBVarIdx.map LamTerm.bvar)

  /-- Refer to docstring of `LamTerm.isGeneral` -/
  def toDefinition? (v : REntry) : ReifM (Option REntry) := do
    let .valid lctx t := v
      | throwError "toDefinition :: Unexpected entry {v}"
    let mut introed := t.betaReduceHacky
    let mut lctx' := lctx
    while true do
      match introed.intro1? with
      | .some (s, i) => introed := i; lctx' := s :: lctx'
      | .none => break
    let .app _ (.app _ (.base head) lhs) rhs := introed
      | return .none
    if !head.isEq && !(head == .iff) then
      return .none
    let ml := lhs.getLamBody.isGeneral (lctx'.length + lhs.getLamTys.length)
    let mr := rhs.getLamBody.isGeneral (lctx'.length + rhs.getLamTys.length)
    if ml.isNone && mr.isNone then return .none
    let .some m := ml <|> mr
      | throwError "toDefinition? :: Unexpected error"
    let v ← validOfBetaReduce v
    let v ← validOfIntroMost v
    let v ← (do if (head == .iff) then validOfPrepConv .validOfPropext v [] else pure v)
    let v ← (do if ml.isNone then validOfEqSymm v else pure v)
    let v ← validOfExtensionalizeEqFNAt v (m.size - lctx'.length) []
    let v ← validOfBetaReduce v
    let v ← validOfIntros v (m.size - lctx'.length)
    let v ← reorderLCtx v m
    let v ← validOfRevertAll v
    let v ← validOfIntensionalizeEqAt v []
    let v ← validOfEtaReduceNAt v m.size [false, true]
    return .some v

  /--
    Recognize all definitions-like facts within `vs`, exhaustively
      rewrite using them and remove them in the end
    Meanwhile, all λterms in the `ts` are rewritten using the
      recognied definitions
  -/
  def recognizeDefsAndUnfold
    (vs : Array REntry) (minds : Array MutualIndInfo) :
    ReifM (Array REntry × Array MutualIndInfo) := do
    let mut active := vs.reverse
    let mut passive := #[]
    let mut minds := minds
    while true do
      let .some back := active.back?
        | break
      active := active.pop
      let .some v' ← toDefinition? back
        | passive := passive.push back; continue
      trace[auto.lamReif.prep.def] "Entry {back} is def-like and is turned into {v'}"
      let .valid [] rw@(.app _ (.app _ (.base (.eq _)) lhs) rhs) := v'
        | throwError "recognizeDefsAndUnfold :: Unexpected definition entry {v'}"
      -- If the left-hand-side occurs inside the right-hand-side,
      --   then this definition is recursive and we will not unfold it
      if rhs.abstractsImp #[lhs] != rhs then
        passive := passive.push back; continue
      passive ← passive.mapM (validOfMpAll · v')
      active ← active.mapM (validOfMpAll · v')
      minds ← minds.mapM (fun mind => do
        let .some mind := mind.mpAll? rw
          | throwError "recognizeDefsAndUnfold :: Unexpected error"
        return mind)
    return (passive, minds)

  register_option auto.lamReif.prep.def : Bool := {
    defValue := true
    descr := "Recognize and unfold definitions"
  }

  def preprocess
    (vs : Array REntry) (minds : Array MutualIndInfo) :
    ReifM (Array REntry × Array MutualIndInfo) := do
    let vs ← vs.mapM validOfBetaReduce
    let vs ← vs.mapM skolemizeMostIntoForall
    let vs ← vs.mapM validOfExtensionalize
    let vs ← vs.mapM validOfBetaReduce
    let (vs, minds) ← (do
      if auto.lamReif.prep.def.get (← getOptions) then
        recognizeDefsAndUnfold vs minds
      else
        return (vs, minds))
    let vs ← vs.mapM validOfBetaReduce
    let vs ← vs.mapM (fun re => validOfPrepConv .validOfPushBVCast re [])
    let vs ← vs.mapM validOfRevertAll
    for v in vs do
      trace[auto.lamReif.prep.printResult] "{v}"
    for mind in minds do
      let smind := String.intercalate "\n" ("" :: mind.map toString)
      trace[auto.lamReif.prep.printResult] "{smind}"
    return (vs, minds)

  def auxLemmas (vs : Array REntry) : ReifM (Array REntry) := do
    let mut ret := #[]
    -- Boolean facts
    if vs.any (fun re => re.containsSort (.base .bool)) then
      let factsConj ← boolFacts
      ret := ret.append (← decomposeAnd factsConj [])
    -- ite specification
    let allLamTerms := (vs.map (fun re => Array.mk (REntry.allLamTerms re))).concatMap id
    let iteSorts := collectLamTermsIteSorts allLamTerms
    ret := ret.append (← iteSorts.toArray.mapM iteSpec)
    return ret

end CheckerUtils

/--
  Accept a new expression representing λterm atom
  Returns the index of it in the `varVal` array
-/
def newTermExprAux (e : Expr) (sort : LamSort) : ReifM LamTerm := do
  let varMap ← getVarMap
  let varVal ← getVarVal
  let idx := varVal.size
  setVarVal (varVal.push (e, sort))
  setVarMap (varMap.insert e idx)
  let _ ← nonemptyOfAtom idx
  return .atom idx

def newTypeExpr (e : Expr) : ReifM LamSort := do
  let tyVarMap ← getTyVarMap
  let tyVal ← getTyVal
  let idx := tyVal.size
  -- The universe level of `e`
  let origSort ← Meta.inferType e
  let origSort := (← instantiateMVars origSort).headBeta
  let .sort lvl := origSort
    | throwError "newTypeExpr :: Unexpected sort {origSort}"
  setTyVal (tyVal.push (e, lvl))
  setTyVarMap (tyVarMap.insert e idx)
  return .atom idx

def processTypeExpr (e : Expr) : ReifM LamSort := do
  let tyVarMap ← getTyVarMap
  let e ← Reif.resolveTy e
  if let .some idx := tyVarMap.find? e then
    return .atom idx
  match e with
  | .sort lvl =>
    if ← Meta.isLevelDefEq lvl .zero then
      return .base .prop
    else
      newTypeExpr e
  | .const ``Bool [] => return .base .bool
  | .const ``Nat [] => return .base .nat
  | .const ``Int [] => return .base .int
  | .const ``String [] => return .base .string
  | .const ``Empty [] => return .base .empty
  | .app (.const ``Std.BitVec []) nExpr =>
    if let .some n ← @id (MetaM _) (Meta.evalNat nExpr) then
      return .base (.bv n)
    else
      newTypeExpr e
  | _ => newTypeExpr e

-- At this point, there should only be non-dependent `∀`s in the type.
private def reifTypeAux : Expr → ReifM LamSort
| .mdata _ e => reifTypeAux e
| e@(.forallE _ ty body _) => do
  if body.hasLooseBVar 0 then
    throwError "reifType :: Type {e} has dependent ∀"
  else
    return .func (← reifTypeAux ty) (← reifTypeAux body)
| e => processTypeExpr e

def reifType (e : Expr) : ReifM LamSort := do
  let e ← prepReduceExpr e
  reifTypeAux e

def newTermExpr (e : Expr) : ReifM LamTerm := do
  let eTy ← instantiateMVars (← Meta.inferType e)
  let lamTy ← reifType eTy
  newTermExprAux e lamTy

-- Auxiliary definitions for reification
abbrev Nat.modEq (n a b : Nat) := a % n = b % n
abbrev Nat.ge (x y : Nat) := Nat.le y x
abbrev Nat.gt (x y : Nat) := Nat.lt y x
abbrev Nat.max (x y : Nat) : Nat := Max.max x y
abbrev Nat.min (x y : Nat) : Nat := Min.min x y
abbrev Int.modEq (n a b : Int) := a % n = b % n
abbrev Int.ge (a b : Int) := Int.le b a
abbrev Int.gt (a b : Int) := Int.lt b a
abbrev Int.max (x y : Int) : Int := Max.max x y
abbrev Int.min (x y : Int) : Int := Min.min x y
abbrev String.ge (a b : String) : Prop := b = a ∨ b < a
abbrev String.gt (a b : String) : Prop := b < a
abbrev BitVec.uge (a b : Std.BitVec n) : Bool := Std.BitVec.ule b a
abbrev BitVec.ugt (a b : Std.BitVec n) : Bool := Std.BitVec.ult b a
abbrev BitVec.sge (a b : Std.BitVec n) : Bool := Std.BitVec.sle b a
abbrev BitVec.sgt (a b : Std.BitVec n) : Bool := Std.BitVec.slt b a
abbrev BitVec.smtHshiftLeft (a : Std.BitVec n) (b : Std.BitVec m) := Std.BitVec.shiftLeft a b.toNat
abbrev BitVec.smtHushiftRight (a : Std.BitVec n) (b : Std.BitVec m) := Std.BitVec.ushiftRight a b.toNat
abbrev BitVec.smtHsshiftRight (a : Std.BitVec n) (b : Std.BitVec m) := Std.BitVec.sshiftRight a b.toNat

def reifMapIL : HashMap Name (LamSort → LamBaseTerm) :=
  HashMap.ofList [
    (``Eq,                .eq),
    (``Embedding.forallF, .forallE),
    (``Exists,            .existE),
    (``Bool.ite',         .ite)
  ]

def reifMapConstNilLvl : HashMap Name LamTerm :=
  HashMap.ofList [
    (``True,              .base .trueE),
    (``False,             .base .falseE),
    (``Not,               .base .not),
    (``And,               .base .and),
    (``Or,                .base .or),
    (``Iff,               .base .iff),
    (``Bool.ofProp,       .base .ofProp),
    (``true,              .base .trueb),
    (``false,             .base .falseb),
    (``not,               .base .notb),
    (``and,               .base .andb),
    (``or,                .base .orb),
    (``Nat.zero,          .base (.natVal 0)),
    (``Nat.succ,          .lam (.base .nat) (.mkNatBinOp .nadd (.bvar 0) (.base (.natVal 1)))),
    (``Nat.add,           .base .nadd),
    (``Nat.sub,           .base .nsub),
    (``Nat.mul,           .base .nmul),
    (``Nat.div,           .base .ndiv),
    (``Nat.mod,           .base .nmod),
    (``Nat.le,            .base .nle),
    (``Nat.lt,            .base .nlt),
    (`Nat.ModEq,          .nmodeq),
    (``Int.ofNat,         .base .iofNat),
    (``Int.negSucc,       .base .inegSucc),
    (``Int.neg,           .base .ineg),
    (``Int.add,           .base .iadd),
    (``Int.sub,           .base .isub),
    (``Int.mul,           .base .imul),
    (``Int.div,           .base .idiv),
    (``Int.mod,           .base .imod),
    (``Int.ediv,          .base .iediv),
    (``Int.emod,          .base .iemod),
    (``Int.le,            .base .ile),
    (``Int.lt,            .base .ilt),
    (`Int.ModEq,          .imodeq),
    (``String.length,     .base .slength),
    (``String.append,     .base .sapp),
    (``String.isPrefixOf, .base .sprefixof),
    (``String.replace,    .base .srepall)
  ]

def reifMapBVConst1 : HashMap Name (Nat → LamTerm) :=
  HashMap.ofList [
    (``Std.BitVec.ofNat,       fun n => .base (.bvofNat n)),
    (``Std.BitVec.toNat,       fun n => .base (.bvtoNat n)),
    (``Std.BitVec.ofInt,       fun n => .base (.bvofInt n)),
    (``Std.BitVec.toInt,       fun n => .base (.bvtoInt n)),
    (``Std.BitVec.msb,         fun n => .base (.bvmsb n)),
    (``Std.BitVec.add,         fun n => .base (.bvadd n)),
    (``Std.BitVec.sub,         fun n => .base (.bvsub n)),
    (``Std.BitVec.neg,         fun n => .base (.bvneg n)),
    (``Std.BitVec.abs,         fun n => .base (.bvabs n)),
    (``Std.BitVec.mul,         fun n => .base (.bvmul n)),
    (``Std.BitVec.smtUDiv,     fun n => .base (.bvudiv n)),
    (``Std.BitVec.umod,        fun n => .base (.bvurem n)),
    (``Std.BitVec.smtSDiv,     fun n => .base (.bvsdiv n)),
    (``Std.BitVec.srem,        fun n => .base (.bvsrem n)),
    (``Std.BitVec.smod,        fun n => .base (.bvsmod n)),
    (``Std.BitVec.ult,         fun n => .base (.bvult n)),
    (``Std.BitVec.ule,         fun n => .base (.bvule n)),
    (``Std.BitVec.slt,         fun n => .base (.bvslt n)),
    (``Std.BitVec.sle,         fun n => .base (.bvsle n)),
    (``Std.BitVec.and,         fun n => .base (.bvand n)),
    (``Std.BitVec.or,          fun n => .base (.bvor n)),
    (``Std.BitVec.xor,         fun n => .base (.bvxor n)),
    (``Std.BitVec.not,         fun n => .base (.bvnot n)),
    (``Std.BitVec.shiftLeft,   fun n => .base (.bvshl n)),
    (``Std.BitVec.ushiftRight, fun n => .base (.bvlshr n)),
    (``Std.BitVec.sshiftRight, fun n => .base (.bvashr n)),
    (``Std.BitVec.rotateLeft,  fun n => .bvrotateLeft n),
    (``Std.BitVec.rotateRight, fun n => .bvrotateRight n)
  ]

def reifMapBVConst2 : HashMap Name (Nat → Nat → LamTerm) :=
  HashMap.ofList [
    (``Std.BitVec.append,     fun n m => .base (.bvappend n m)),
    (``Std.BitVec.replicate,  fun w i => .base (.bvrepeat w i)),
    (``Std.BitVec.zeroExtend, fun w v => .base (.bvzeroExtend w v)),
    (``Std.BitVec.signExtend, fun w v => .base (.bvsignExtend w v))
  ]

def reifMapBVConst3 : HashMap Name (Nat → Nat → Nat → LamTerm) :=
  HashMap.ofList [
    (``Std.BitVec.extractLsb, fun n h l => .base (.bvextract n h l))
  ]

def processSimpleLit (l : Literal) : LamTerm :=
  match l with
  | .natVal n => .base (.natVal n)
  | .strVal s => .base (.strVal s)

def processSimpleConst (name : Name) (lvls : List Level) : ReifM (Option LamTerm) := do
  if let .some t := reifMapConstNilLvl.find? name then
    if lvls.length != 0 then
      throwError "processSimpleConst :: ConstNilLvl constants should have nil level list"
    return t
  if name == ``Embedding.ImpF then
    let [u, v] := lvls
      | throwError "processSimpleConst :: Invalid levels {lvls} for Auto.Embedding.ImpF"
    if (← Meta.isLevelDefEq u .zero) ∧ (← Meta.isLevelDefEq v .zero) then
      return .some (.base .imp)
    else
      throwError "processSimpleConst :: Non-propositional implication is not supported"
  return .none

def processSimpleApp (fn arg : Expr) : ReifM (Option LamTerm) := do
  let args := fn.getAppArgs ++ #[arg]
  let fn := fn.getAppFn
  let .const name lvls := fn
    | return .none
  match args.data with
  | [] => throwError "processSimpleApp :: Unexpected error"
  | [arg] =>
    if let .some tcon := reifMapBVConst1.find? name then
      if lvls.length != 0 then
        throwError "processSimpleApp :: BVConst1 should have nil level list"
      if let .some n ← @id (MetaM _) (Meta.evalNat arg) then
        return .some (tcon n)
      return .none
      -- `arg` is the original (un-lifted) type
    if let .some tcon := reifMapIL.find? name then
      return .some (.base (tcon (← reifType arg)))
    return .none
  | [arg₁, arg₂] =>
    if let .some tcon := reifMapBVConst2.find? name then
      if lvls.length != 0 then
        throwError "processSimpleApp :: BVConst2 should have nil level list"
      match ← @id (MetaM _) (Meta.evalNat arg₁),
            ← @id (MetaM _) (Meta.evalNat arg₂) with
      | .some n, .some m => return .some (tcon n m)
      | _,       _       => return .none
    return .none
  | [arg₁, arg₂, arg₃] =>
    if let .some tcon := reifMapBVConst3.find? name then
      if lvls.length != 0 then
        throwError "processSimpleApp :: BVConst2 should have nil level list"
      match ← @id (MetaM _) (Meta.evalNat arg₁),
            ← @id (MetaM _) (Meta.evalNat arg₂),
            ← @id (MetaM _) (Meta.evalNat arg₃) with
      | .some n, .some h, .some l => return .some (tcon n h l)
      | _,       _,       _       => return .none
    return .none
  | _ => return .none

/--
  fn   : .const _ _
  arg₁ : .const _ _
-/
def reifMapLam0Arg2NoLit : HashMap (Name × Name) (Expr × LamTerm) :=
  HashMap.ofList [
    ((``NatCast.natCast, ``Int), (.const ``Int.ofNat [], .base .iofNat)),
    ((``Neg.neg, ``Int),         (.const ``Int.neg [], .base .ineg)),
    ((`Abs.abs, ``Int),          (.const ``Int.abs [], .base .iabs)),
    ((``LE.le, ``Nat),           (.const ``Nat.le [], .base .nle)),
    ((``LE.le, ``Int),           (.const ``Int.le [], .base .ile)),
    ((``LE.le, ``String),        (.const ``String.le [], .base .sle)),
    ((``GE.ge, ``Nat),           (.const ``Nat.ge [], .nge)),
    ((``GE.ge, ``Int),           (.const ``Int.ge [], .ige)),
    ((``GE.ge, ``String),        (.const ``String.ge [], .sge)),
    ((``LT.lt, ``Nat),           (.const ``Nat.lt [], .base .nlt)),
    ((``LT.lt, ``Int),           (.const ``Int.lt [], .base .ilt)),
    ((``LT.lt, ``String),        (.const ``String.lt [], .base .slt)),
    ((``GT.gt, ``Nat),           (.const ``Nat.gt [], .ngt)),
    ((``GT.gt, ``Int),           (.const ``Int.gt [], .igt)),
    ((``GT.gt, ``String),        (.const ``String.gt [], .sgt)),
    ((``Max.max, ``Nat),         (.const ``Nat.max [], .base .nmax)),
    ((``Max.max, ``Int),         (.const ``Int.max [], .base .imax)),
    ((``Min.min, ``Nat),         (.const ``Nat.min [], .base .nmin)),
    ((``Min.min, ``Int),         (.const ``Int.min [], .base .imin))
  ]

/--
  fn   : .const _ _
  arg₁ : .app (.const _ _) natlit
-/
def reifMapLam0Arg2Natlit : HashMap (Name × Name) (Array ((Nat → Expr) × (Nat → LamTerm))) :=
  HashMap.ofList [
    ((``Neg.neg, ``Std.BitVec),
              #[(fun n => .app (.const ``Std.BitVec.neg []) (.lit (.natVal n)), fun n => .base (.bvneg n))]),
    ((`Abs.abs, ``Std.BitVec),
              #[(fun n => .app (.const ``Std.BitVec.abs []) (.lit (.natVal n)), fun n => .base (.bvabs n))]),
    ((``Complement.complement, ``Std.BitVec),
              #[(fun n => .app (.const ``Std.BitVec.not []) (.lit (.natVal n)), fun n => .base (.bvnot n))]),
    ((``LE.le, ``Std.BitVec),
              #[(fun n => .app (.const ``Std.BitVec.ule []) (.lit (.natVal n)), fun n => .base (.bvule n)),
                (fun n => .app (.const ``Std.BitVec.sle []) (.lit (.natVal n)), fun n => .base (.bvsle n))]),
    ((``GE.ge, ``Std.BitVec),
              #[(fun n => .app (.const ``BitVec.uge []) (.lit (.natVal n)), fun n => .bvuge n),
                (fun n => .app (.const ``BitVec.sge []) (.lit (.natVal n)), fun n => .bvsge n)]),
    ((``LT.lt, ``Std.BitVec),
              #[(fun n => .app (.const ``Std.BitVec.ult []) (.lit (.natVal n)), fun n => .base (.bvult n)),
                (fun n => .app (.const ``Std.BitVec.slt []) (.lit (.natVal n)), fun n => .base (.bvslt n))]),
    ((``GT.gt, ``Std.BitVec),
              #[(fun n => .app (.const ``BitVec.ugt []) (.lit (.natVal n)), fun n => .bvugt n),
                (fun n => .app (.const ``BitVec.sgt []) (.lit (.natVal n)), fun n => .bvsgt n)])
  ]

/--
  fn   : .const _ _
  arg₁ : .const _ _
  arg₂ : .const _ _
-/
def reifMapLam0Arg4NoLit : HashMap (Name × Name × Name) (Expr × LamTerm) :=
  HashMap.ofList [
    ((``HAdd.hAdd, ``Nat, ``Nat),             (.const ``Nat.add [], .base .nadd)),
    ((``HAdd.hAdd, ``Int, ``Int),             (.const ``Int.add [], .base .iadd)),
    ((``HSub.hSub, ``Nat, ``Nat),             (.const ``Nat.sub [], .base .nsub)),
    ((``HSub.hSub, ``Int, ``Int),             (.const ``Int.sub [], .base .isub)),
    ((``HMul.hMul, ``Nat, ``Nat),             (.const ``Nat.mul [], .base .nmul)),
    ((``HMul.hMul, ``Int, ``Int),             (.const ``Int.mul [], .base .imul)),
    ((``HDiv.hDiv, ``Nat, ``Nat),             (.const ``Nat.div [], .base .ndiv)),
    ((``HDiv.hDiv, ``Int, ``Int),             (.const ``Int.div [], .base .idiv)),
    ((``HAppend.hAppend, ``String, ``String), (.const ``String.append [], .base .sapp))
  ]

/--
  fn   : .const _ _
  arg₁ : .app (.const _ _) natlit₁
  arg₂ : .app (.const _ _) natlit₂
  |- natlit₁ = natlit₂
-/
def reifMapLam0Arg4NatLitNatLitEq : HashMap (Name × Name) (Array ((Nat → Expr) × (Nat → LamTerm))) :=
  HashMap.ofList [
    ((``HAdd.hAdd, ``Std.BitVec),
      #[(fun n => .app (.const ``Std.BitVec.add []) (.lit (.natVal n)), fun n => .base (.bvadd n))]),
    ((``HSub.hSub, ``Std.BitVec),
      #[(fun n => .app (.const ``Std.BitVec.sub []) (.lit (.natVal n)), fun n => .base (.bvsub n))]),
    ((``HMul.hMul, ``Std.BitVec),
      #[(fun n => .app (.const ``Std.BitVec.mul []) (.lit (.natVal n)), fun n => .base (.bvmul n))]),
    ((``HDiv.hDiv, ``Std.BitVec),
      #[(fun n => .app (.const ``Std.BitVec.smtUDiv []) (.lit (.natVal n)), fun n => .base (.bvudiv n)),
        (fun n => .app (.const ``Std.BitVec.smtSDiv []) (.lit (.natVal n)), fun n => .base (.bvsdiv n))]),
    ((``HAnd.hAnd, ``Std.BitVec),
      #[(fun n => .app (.const ``Std.BitVec.and []) (.lit (.natVal n)), fun n => .base (.bvand n))]),
    ((``HOr.hOr, ``Std.BitVec),
      #[(fun n => .app (.const ``Std.BitVec.or []) (.lit (.natVal n)), fun n => .base (.bvor n))]),
    ((``HXor.hXor, ``Std.BitVec),
      #[(fun n => .app (.const ``Std.BitVec.xor []) (.lit (.natVal n)), fun n => .base (.bvxor n))])
  ]

/--
  fn   : .const _ _
  arg₁ : .app (.const _ _) natlit₁
  arg₂ : .app (.const _ _) natlit₂
  |- natlit₁ ?? natlit₂
-/
def reifMapLam0Arg4NatLitNatLitH : HashMap (Name × Name) (Array ((Nat → Nat → Expr) × (Nat → Nat → LamTerm))) :=
  HashMap.ofList [
    ((``HAppend.hAppend, ``Std.BitVec),
      #[(fun n m => mkApp2 (.const ``Std.BitVec.append []) (.lit (.natVal n)) (.lit (.natVal m)), fun n m => .base (.bvappend n m))]),
    ((``HShiftLeft.hShiftLeft, ``Std.BitVec),
      #[(fun n m => mkApp2 (.const ``BitVec.smtHshiftLeft []) (.lit (.natVal n)) (.lit (.natVal m)), fun n m => .bvsmtHshl n m)]),
    ((``HShiftRight.hShiftRight, ``Std.BitVec),
      #[(fun n m => mkApp2 (.const ``BitVec.smtHushiftRight []) (.lit (.natVal n)) (.lit (.natVal m)), fun n m => .bvsmtHlshr n m),
        (fun n m => mkApp2 (.const ``BitVec.smtHsshiftRight []) (.lit (.natVal n)) (.lit (.natVal m)), fun n m => .bvsmtHashr n m)])
  ]

/--
  fn   : .const _ _
  arg₁ : .app (.const _ _) natlit
  arg₂ : .const _ _
-/
def reifMapLam0Arg4NatLit : HashMap (Name × Name) (Array ((Nat → Expr) × (Nat → LamTerm))) :=
  HashMap.ofList [
    ((``HShiftLeft.hShiftLeft, ``Std.BitVec),
      #[(fun n => .app (.const ``Std.BitVec.shiftLeft []) (.lit (.natVal n)), fun n => .base (.bvshl n))]),
    ((``HShiftRight.hShiftRight, ``Std.BitVec),
      #[(fun n => .app (.const ``Std.BitVec.ushiftRight []) (.lit (.natVal n)), fun n => .base (.bvlshr n)),
        (fun n => .app (.const ``Std.BitVec.sshiftRight []) (.lit (.natVal n)), fun n => .base (.bvashr n))])
  ]

def processLam0Arg2 (e fn arg₁ arg₂ : Expr) : MetaM (Option LamTerm) := do
  let .const fnName _ := fn
    | return .none
  if arg₁.isConst then
    let .const arg₁Name _ := arg₁
      | throwError "processLam0Arg2 :: Unexpected error"
    if let .some (e', t) := reifMapLam0Arg2NoLit.find? (fnName, arg₁Name) then
      if (← Meta.isDefEqD e e') then
        return .some t
  if arg₁.isApp then
    let .app arg₁fn arg₁arg := arg₁
      | throwError "processLam0Arg2 :: Unexpected error"
    if let .const arg₁FnName _ := arg₁fn then
      if let .some candidates := reifMapLam0Arg2Natlit.find? (fnName, arg₁FnName) then
        for (e'con, tcon) in candidates do
          if let .some n ← Meta.evalNat arg₁arg then
            if (← Meta.isDefEqD e (e'con n)) then
              return .some (tcon n)
  return .none

def processLam0Arg3 (e fn arg₁ arg₂ arg₃ : Expr) : MetaM (Option LamTerm) := do
  match fn with
  | .const ``OfNat.ofNat _ =>
    match arg₁ with
    | .const ``Nat _ =>
      if (← Meta.isDefEqD e arg₂) then
        let .lit (.natVal nv) := arg₂
          | throwError "processLam0Arg3 :: OfNat.ofNat instance is not based on a nat literal"
        return .some (.base (.natVal nv))
      return .none
    | .const ``Int _ =>
      if (← Meta.isDefEqD e (.app (.const ``Int.ofNat []) arg₂)) then
        let .lit (.natVal nv) := arg₂
          | throwError "processLam0Arg3 :: OfNat.ofNat instance is not based on a nat literal"
        return .some (.mkIOfNat (.base (.natVal nv)))
      return .none
    | .app (.const ``Std.BitVec []) nExpr =>
      if let .some n ← Meta.evalNat nExpr then
        if (← Meta.isDefEqD e (mkApp2 (.const ``Std.BitVec.ofNat []) (.lit (.natVal n)) arg₂)) then
          let .lit (.natVal nv) := arg₂
            | throwError "processLam0Arg3 :: OfNat.ofNat instance is not based on a nat literal"
          return .some (.base (.bvVal n nv))
      return .none
    | _ => return .none
  | _ => return .none

def processLam0Arg4 (e fn arg₁ arg₂ arg₃ arg₄ : Expr) : MetaM (Option LamTerm) := do
  let .const fnName _ := fn
    | return .none
  if arg₁.isConst && arg₂.isConst then
    let .const arg₁name _ := arg₁
      | throwError "processLam0Arg4 :: Unexpected error"
    let .const arg₂name _ := arg₂
      | throwError "processLam0Arg4 :: Unexpected error"
    if let .some (e', t) := reifMapLam0Arg4NoLit.find? (fnName, arg₁name, arg₂name) then
      if (← Meta.isDefEqD e e') then
        return .some t
      return .none
  if arg₁.isApp && arg₂.isConst then
    let .app arg₁fn arg₁arg := arg₁
      | throwError "processLam0Arg4 :: Unexpected error"
    if arg₁fn.isConst then
      let .const arg₁fnName _ := arg₁fn
        | throwError "processLam0Arg4 :: Unexpected error {arg₁fn}"
      if let .some candidates := reifMapLam0Arg4NatLit.find? (fnName, arg₁fnName) then
        for (e'con, tcon) in candidates do
          if let .some n ← Meta.evalNat arg₁arg then
            if (← Meta.isDefEqD e (e'con n)) then
              return tcon n
  if arg₁.isApp && arg₂.isApp then
    let .app arg₁fn arg₁arg := arg₁
      | throwError "processLam0Arg4 :: Unexpected error"
    let .app arg₂fn arg₂arg := arg₂
      | throwError "processLam0Arg4 :: Unexpected error"
    if arg₁fn.isConst && arg₂fn.isConst then
      let .const arg₁fnName _ := arg₁fn
        | throwError "processLam0Arg4 :: Unexpected error"
      if let .some candidates := reifMapLam0Arg4NatLitNatLitEq.find? (fnName, arg₁fnName) then
        for (e'con, tcon) in candidates do
          if let .some n ← Meta.evalNat arg₁arg then
            if (← Meta.isDefEqD e (e'con n)) then
              return tcon n
      if let .some candidates := reifMapLam0Arg4NatLitNatLitH.find? (fnName, arg₁fnName) then
        for (e'con, tcon) in candidates do
          match ← Meta.evalNat arg₁arg, ← Meta.evalNat arg₂arg with
          | .some n , .some m =>
            if (← Meta.isDefEqD e (e'con n m)) then
              return .some (tcon n m)
            return .none
          | _,        _       => return .none
  return .none

def processComplexTermExpr (e : Expr) : MetaM (Option LamTerm) := do
  let e := Expr.eta e
  let lams := (Expr.lambdaBinders e).size
  match lams with
  | 0 =>
    let fn := e.getAppFn
    let args := e.getAppArgs
    match args.data with
    | [] => return .none
    | [_] => return .none
    | [arg₁, arg₂] => processLam0Arg2 e fn arg₁ arg₂
    | [arg₁, arg₂, arg₃] => processLam0Arg3 e fn arg₁ arg₂ arg₃
    | [arg₁, arg₂, arg₃, arg₄] =>
      processLam0Arg4 e fn arg₁ arg₂ arg₃ arg₄
    | _ => return .none
  | _ => return .none

def processNewTermExpr (e : Expr) : ReifM LamTerm := do
  let e := e.eta
  match e with
  | .lit l => return processSimpleLit l
  | .const name lvls => do
    match ← processSimpleConst name lvls with
    | .some t => return t
    | .none => processOther e
  | .app fn arg => do
    match ← processSimpleApp fn arg with
    | .some t => return t
    | .none => processOther e
  | e => processOther e
where
  processOther (e : Expr) := do
    if let .some res ← processComplexTermExpr e then
      return res
    newTermExpr e

def processTermExpr (lctx : HashMap FVarId Nat) (e : Expr) : ReifM LamTerm := do
  if let .fvar fid := e then
    if let .some n := deBruijn? lctx fid then
      return .bvar n
  let e ← Reif.resolveVal e
  let varMap ← getVarMap
  -- If the expression has already been processed
  if let .some id := varMap.find? e then
    return .atom id
  -- If the expression has not been processed
  processNewTermExpr e
where
  deBruijn? (lctx : HashMap FVarId Nat) (id : FVarId) : Option Nat :=
    match lctx.find? id with
    | .some n => lctx.size - 1 - n
    | .none   => none

partial def reifTerm (lctx : HashMap FVarId Nat) : Expr → ReifM LamTerm
| .app fn arg => do
  let lamFn ← reifTerm lctx fn
  let lamArg ← reifTerm lctx arg
  let argTy ← Meta.inferType arg
  let lamTy ← reifType argTy
  return .app lamTy lamFn lamArg
| .lam name ty body binfo => do
  let lamTy ← reifType ty
  let body ← Meta.withLocalDecl name binfo ty fun fvar => do
    let body' := body.instantiate1 fvar
    reifTerm (lctx.insert fvar.fvarId! lctx.size) body'
  return .lam lamTy body
| e => processTermExpr lctx e

def reifTermCheckType (e : Expr) : ReifM (LamSort × LamTerm) := do
  let t ← reifTerm .empty e
  let ltv ← getLamTyValAtMeta
  let .some s := t.lamCheck? ltv Embedding.Lam.dfLCtxTy
    | throwError "reifTermCheckType :: LamTerm {t} is not type correct"
  return (s, t)

/-- Return the positions of the reified and `resolveImport`-ed facts within the `validTable` -/
def reifFacts (facts : Array UMonoFact) : ReifM (Array LamTerm) :=
  facts.mapM (fun (proof, ty) => do
    let (s, lamty) ← reifTermCheckType ty
    if s != .base .prop then
      throwError "reifFacts :: Fact {lamty} is not of type `prop`"
    trace[auto.lamReif.printResult] "Successfully reified proof of {← Meta.zetaReduce ty} to λterm `{lamty}`"
    newAssertion proof lamty
    return lamty)

def reifInhabitations (inhs : Array UMonoFact) : ReifM (Array LamSort) :=
  inhs.mapM (fun (inhTy, ty) => do
    let s ← reifType ty
    newInhabitation inhTy s
    trace[auto.lamReif.printResult] "Successfully reified inhabitation proof of {ty} to λsort `{s}`"
    return s)

def reifInd (ind : SimpleIndVal) : ReifM (Option IndInfo) := do
  let ⟨name, type, ctors, projs⟩ := ind
  if name == ``Nat || name == ``Int || name == ``Bool ||
     name == ``String || name == ``String.Pos || name == ``Empty ||
     name == ``Std.BitVec then
    return .none
  -- For now, do not reify inductively defined proposition
  if ← isIndProp name then
    return .none
  let rty ← reifType type
  let rctors ← ctors.mapM (fun (e, _) => reifTermCheckType e)
  let rprojs ← projs.mapM (fun ps => ps.mapM reifTermCheckType)
  let ret := ⟨rty, rctors.data, rprojs.bind (·.data)⟩
  trace[auto.lamReif.printResult] "Successfully reified inductive info {← ind.zetaReduce} to {ret}"
  return .some ret

def reifMutInd (mind : Array SimpleIndVal) : ReifM (Option MutualIndInfo) := do
  let mut ret := #[]
  for ind in mind do
    let .some ii ← reifInd ind
      | return .none
    ret := ret.push ii
  return ret.data

def reifMutInds (minds : Array (Array SimpleIndVal)) : ReifM (Array MutualIndInfo) := do
  let mut ret := #[]
  for mind in minds do
    let .some mi ← reifMutInd mind
      | continue
    ret := ret.push mi
  return ret

section BuildChecker

  inductive BuildMode where
    | directReduce
    | indirectReduce
    | indirectReduce_reflection
  deriving BEq, Hashable, Inhabited

  instance : ToString BuildMode where
    toString : BuildMode → String
    | .directReduce => "directReduce"
    | .indirectReduce => "indirectReduce"
    | .indirectReduce_reflection => "indirectReduce_reflection"

  instance : Lean.KVMap.Value BuildMode where
    toDataValue n := toString n
    ofDataValue?
    | "directReduce" => some .directReduce
    | "indirectReduce" => some .indirectReduce
    | "indirectReduce_reflection" => some .indirectReduce_reflection
    | _ => none

  register_option auto.checker.buildMode : BuildMode := {
    defValue := BuildMode.indirectReduce
    descr := "Mode when building the checker"
  }

  def buildChkStepsExpr : ReifM Expr := do
    let rst ← getRst
    let mut chkSteps := #[]
    for re in (← getRTable) do
      if let .some cs := rst.chkMap.find? re then
        let .some n := rst.findPos? re
          | throwError "buildChkStepsExpr :: Unexpected error"
        chkSteps := chkSteps.push (cs, n)
    -- `ChkMap` are run using `foldl`, so we use `BinTree.ofListFoldl`
    let e := Lean.toExpr (BinTree.ofListFoldl chkSteps.data)
    return e

    -- Given a list of expression of type `ty`, construct the corresponding `BinTree`
  private def exprListToBinTree (l : List Expr) (lvl : Level) (ty : Expr) :=
    (@instToExprBinTree Expr (instExprToExprId ty) ⟨lvl, Prop⟩).toExpr (BinTree.ofListGet l)

    -- Given a list of expression of type `ty`, construct the corresponding `lctx`
  private def exprListToLCtx (l : List Expr) (lvl : Level) (ty : Expr) :=
    @BinTree.toLCtx Expr ⟨lvl, Prop⟩ (instExprToExprId ty) (BinTree.ofListGet l)

  def buildTyVal : ReifM Expr := do
    let u ← getU
    -- `tyVal : List (Type u)`
    let tyVal : List Expr := (← getTyVal).data.map (fun (e, lvl) =>
      Expr.app (.const ``Embedding.GLift [lvl, u]) e)
    -- `tyValExpr : Nat → Type u`
    let tyValExpr := exprListToLCtx tyVal (.succ u) (.sort (.succ u)) (.sort u)
    return tyValExpr

  /-- **Build `LamVarTy` and `varVal`** -/
  def buildVarExpr (tyValExpr : Expr) : ReifM Expr := do
    let u ← getU
    let lamSortExpr := Expr.const ``LamSort []
    let varValPair := (← getVarVal).data
    let vars ← varValPair.mapM (fun (e, s) => do
      let sExpr := toExpr s
      return Lean.mkApp3 (.const ``varSigmaMk [u]) tyValExpr sExpr (← varValInterp e s))
    return exprListToBinTree vars u (Lean.mkApp2
      (.const ``Sigma [.zero, u]) lamSortExpr
      (.app (.const ``LamSort.interp [u]) tyValExpr))

  /-- **Build `lamILTy` and `ilVal`** -/
  def buildILExpr (tyValExpr : Expr) : ReifM Expr := do
    let u ← getU
    let lamSortExpr := Expr.const ``LamSort []
    let lamILTy := (← getLamILTy).data
    -- `ils : List ((s : LamSort) × ILLift.{u} (s.interp tyVal))`
    let ils ← lamILTy.mapM (fun s => do
      let sExpr := toExpr s
      let ilVal ← mkImportingILLift s
      return Lean.mkApp3 (.const ``ilSigmaMk [u]) tyValExpr sExpr ilVal)
    return exprListToBinTree ils u (Lean.mkApp2
      (.const ``Sigma [.zero, u]) lamSortExpr
      (.app (.const ``ilβ [u]) tyValExpr))

  def buildCPValExpr : ReifM Expr := do
    -- let startTime ← IO.monoMsNow
    let u ← getU
    let tyValExpr ← buildTyVal
    let tyValTy := Expr.forallE `_ (.const ``Nat []) (.sort (.succ u)) .default
    let lamValuationExpr ← Meta.withLetDecl `tyVal tyValTy tyValExpr fun tyValFVarExpr => do
      let varExpr ← buildVarExpr tyValFVarExpr
      let ilExpr ← buildILExpr tyValFVarExpr
      let checkerValuationExpr := Lean.mkApp3 (.const ``CPVal.mk [u]) tyValExpr varExpr ilExpr
      Meta.mkLetFVars #[tyValFVarExpr] checkerValuationExpr
    -- if !(← Meta.isTypeCorrectCore lamValuationExpr) then
    --   throwError "buildLamValuation :: Malformed LamValuation"
    -- trace[auto.buildChecker] "LamValuation typechecked in time {(← IO.monoMsNow) - startTime}"
    return lamValuationExpr

  /-- `lvalExpr` is the `LamValuation` -/
  def buildImportTableExpr (chkValExpr : Expr) : ReifM (Expr × Expr) := do
    -- let startTime ← IO.monoMsNow
    let u ← getU
    let mut importTable : BinTree Expr := BinTree.leaf
    let mut importedFactsTree : BinTree REntry := BinTree.leaf
    for (t, (e, ti, n)) in (← getAssertions).toList do
      let tExpr := Lean.toExpr ti
      let ieExpr := Expr.app (.const ``ImportEntry.valid []) tExpr
      let itEntry := Lean.mkApp3 (.const ``importTablePSigmaMk [u]) chkValExpr ieExpr e
      importTable := importTable.insert n itEntry
      if t.maxLooseBVarSucc != 0 || t.maxEVarSucc != 0 then
        throwError "buildImportTableExpr :: Invalid imported fact {t}"
      let veEntry := REntry.valid [] t
      importedFactsTree := importedFactsTree.insert n veEntry
    for (s, (inh, n)) in (← getInhabitations).toList do
      let sExpr := Lean.toExpr s
      let ieExpr := Expr.app (.const ``ImportEntry.nonempty []) sExpr
      let (upFunc, _, _, sil) ← updownFunc s
      let inhLift := Lean.mkApp2 (.const ``Nonempty.intro [.succ u]) sil (.app upFunc inh)
      let itEntry := Lean.mkApp3 (.const ``importTablePSigmaMk [u]) chkValExpr ieExpr inhLift
      importTable := importTable.insert n itEntry
      let vEntry := REntry.nonempty s
      importedFactsTree := importedFactsTree.insert n vEntry
    let type := Lean.mkApp2 (.const ``PSigma [.succ .zero, .zero])
      (.const ``ImportEntry []) (.app (.const ``importTablePSigmaβ [u]) chkValExpr)
    let importTableExpr := (@instToExprBinTree Expr
      (instExprToExprId type) ⟨.zero, Prop⟩).toExpr importTable
    let importedFacts := Lean.toExpr importedFactsTree
    return (importTableExpr, importedFacts)

  /--
    `re` is the entry we want to retrieve from the `validTable`
    The `expr` returned is a proof of the `LamThmValid`-ness of the entry
  -/
  def buildFullCheckerExprFor_directReduce (re : REntry) : ReifM Expr := do
    printCheckerStats
    let startTime ← IO.monoMsNow
    let u ← getU
    let cpvExpr ← buildCPValExpr
    let cpvTy := Expr.const ``CPVal [u]
    let checker ← Meta.withLetDecl `cpval cpvTy cpvExpr fun cpvFVarExpr => do
      let (itExpr, _) ← buildImportTableExpr cpvFVarExpr
      let csExpr ← buildChkStepsExpr
      let .valid lctx t := re
        | throwError "buildFullCheckerExprFor :: {re} is not a `valid` entry"
      let vExpr := Lean.toExpr (← lookupREntryPos! re)
      let eqExpr ← Meta.mkAppM ``Eq.refl #[← Meta.mkAppM ``Option.some #[Lean.toExpr (lctx, t)]]
      let getEntry := Lean.mkApp7 (.const ``Checker.getValidExport_directReduce [u])
        (Lean.toExpr lctx) (Lean.toExpr t) cpvFVarExpr itExpr csExpr vExpr eqExpr
      let getEntry ← Meta.mkLetFVars #[cpvFVarExpr] getEntry
      trace[auto.buildChecker] "Checker expression built in time {(← IO.monoMsNow) - startTime}ms"
      return getEntry
    return checker

  /--
    `re` is the entry we want to retrieve from the `validTable`
    The `expr` returned is a proof of the `LamThmValid`-ness of the entry
  -/
  def buildFullCheckerExprFor_indirectReduce (re : REntry) : ReifM Expr := do
    printCheckerStats
    let startTime ← IO.monoMsNow
    let u ← getU
    let lvtExpr := Lean.toExpr (BinTree.ofListGet ((← getVarVal).map Prod.snd).data)
    let litExpr := Lean.toExpr (BinTree.ofListGet (← getLamILTy).data)
    let cpvExpr ← buildCPValExpr
    let cpvTy := Expr.const ``CPVal [u]
    let checker ← Meta.withLetDecl `cpval cpvTy cpvExpr fun cpvFVarExpr => do
      let (itExpr, ifExpr) ← buildImportTableExpr cpvFVarExpr
      let csExpr ← buildChkStepsExpr
      let .valid lctx t := re
        | throwError "buildFullCheckerExprFor :: {re} is not a `valid` entry"
      let vExpr := Lean.toExpr (← lookupREntryPos! re)
      let hImportExpr ← Meta.mkAppM ``Eq.refl #[ifExpr]
      let hLvtExpr ← Meta.mkAppM ``Eq.refl #[lvtExpr]
      let hLitExpr ← Meta.mkAppM ``Eq.refl #[litExpr]
      let heqExpr ← Meta.mkAppM ``Eq.refl #[← Meta.mkAppM ``Option.some #[Lean.toExpr (lctx, t)]]
      let getEntry := Lean.mkAppN (.const ``Checker.getValidExport_indirectReduce [u])
        #[cpvFVarExpr, itExpr, csExpr, vExpr, ifExpr, hImportExpr,
          lvtExpr, litExpr, hLvtExpr, hLitExpr, Lean.toExpr lctx, Lean.toExpr t, heqExpr]
      let getEntry ← Meta.mkLetFVars #[cpvFVarExpr] getEntry
      trace[auto.buildChecker] "Checker expression built in time {(← IO.monoMsNow) - startTime}ms"
      return getEntry
    return checker

  private def mkNativeAuxDecl (baseName : Name) (type value : Expr) : Reif.ReifM Name := do
    let auxName ← Reif.mkAuxName baseName
    let decl := Declaration.defnDecl {
      name := auxName, levelParams := [], type, value
      hints := .abbrev
      safety := .safe
    }
    let startTime₁ ← IO.monoMsNow
    addDecl decl
    let startTime₂ ← IO.monoMsNow
    withOptions (fun opts => opts.set ``compiler.enableNew false) <| compileDecl decl
    trace[auto.buildChecker] m!"For {auxName}, type checking took {startTime₂ - startTime₁}" ++
      m!"compilation took {(← IO.monoMsNow) - startTime₁}ms"
    return auxName

  /--
    This can be used to shows the issue that compilation of a reduced
      expression exhibits superlinear behaviour. Try the examples in
      `Test/CheckerScalability/Skolemization.lean`
    This function is not intended to be called in practice
  -/
  def compileRunResultExpr : ReifM Name := do
    let runResultExpr := Lean.mkApp3 (.const ``RTable.mk [])
      (Lean.toExpr (← getRTableTree)) (Lean.toExpr (← getMaxEVarSucc))
      (Lean.toExpr (← getLamEVarTyTree))
    mkNativeAuxDecl "lam_ssrefl_rr" (Lean.mkConst ``RTable) runResultExpr

  def buildFullCheckerExprFor_indirectReduce_reflection (re : REntry) : ReifM Expr := do
    printCheckerStats
    let startTime ← IO.monoMsNow
    let u ← getU
    let lvtExpr := Lean.toExpr (BinTree.ofListGet ((← getVarVal).map Prod.snd).data)
    let lvtNativeName ← mkNativeAuxDecl "lam_ssrefl_lvt" (Expr.app (.const ``BinTree [.zero]) (Lean.mkConst ``LamSort)) lvtExpr
    let litExpr := Lean.toExpr (BinTree.ofListGet (← getLamILTy).data)
    let litNativeName ← mkNativeAuxDecl "lam_ssrefl_lit" (Expr.app (.const ``BinTree [.zero]) (Lean.mkConst ``LamSort)) litExpr
    let cpvExpr ← buildCPValExpr
    let cpvTy := Expr.const ``CPVal [u]
    let checker ← Meta.withLetDecl `cpval cpvTy cpvExpr fun cpvFVarExpr => do
      let (itExpr, ifExpr) ← buildImportTableExpr cpvFVarExpr
      let ifNativeName ← mkNativeAuxDecl "lam_ssrefl_if" (Expr.app (.const ``BinTree [.zero]) (Lean.mkConst ``REntry)) ifExpr
      let csExpr ← buildChkStepsExpr
      let csNativeName ← mkNativeAuxDecl "lam_ssrefl_cs" (Lean.mkConst ``ChkSteps) csExpr
      let .valid lctx t := re
        | throwError "buildFullCheckerExprFor :: {re} is not a `valid` entry"
      let vExpr := Lean.toExpr (← lookupREntryPos! re)
      let hImportExpr ← Meta.mkAppM ``Eq.refl #[Lean.mkConst ifNativeName]
      let hLvtExpr ← Meta.mkAppM ``Eq.refl #[Lean.mkConst lvtNativeName]
      let hLitExpr ← Meta.mkAppM ``Eq.refl #[Lean.mkConst litNativeName]
      let heqBoolExpr := Lean.mkApp7 (.const ``Checker.getValidExport_indirectReduce_reflection_runEq [])
        (Lean.mkConst lvtNativeName) (Lean.mkConst litNativeName) (Lean.mkConst ifNativeName)
        (Lean.mkConst csNativeName) vExpr (Lean.toExpr lctx) (Lean.toExpr t)
      let heqNativeName ← mkNativeAuxDecl "lam_ssrefl_hEq" (Lean.mkConst ``Bool) heqBoolExpr
      let heqRflPrf ← Meta.mkEqRefl (toExpr true)
      let heqExpr := mkApp3 (Lean.mkConst ``Lean.ofReduceBool) (Lean.mkConst heqNativeName) (toExpr true) heqRflPrf
      let getEntry := Lean.mkAppN (.const ``Checker.getValidExport_indirectReduce_reflection [u])
        #[cpvFVarExpr, itExpr, csExpr, vExpr, ifExpr, hImportExpr,
          lvtExpr, litExpr, hLvtExpr, hLitExpr, Lean.toExpr lctx, Lean.toExpr t, heqExpr]
      let getEntry ← Meta.mkLetFVars #[cpvFVarExpr] getEntry
      trace[auto.buildChecker] "Checker expression built in time {(← IO.monoMsNow) - startTime}ms"
      return getEntry
    return checker

  def buildFullCheckerExprFor (re : REntry) : ReifM Expr := do
    let buildMode := auto.checker.buildMode.get (← getOptions)
    match buildMode with
    | .directReduce => buildFullCheckerExprFor_directReduce re
    | .indirectReduce => buildFullCheckerExprFor_indirectReduce re
    | .indirectReduce_reflection => buildFullCheckerExprFor_indirectReduce_reflection re

end BuildChecker

end LamReif


namespace Lam2Lam
open Embedding.Lam LamReif

  structure TState where
    typeH2lMap : HashMap Nat Nat            := {}
    -- This field should be in sync with `LamReif.State.tyVal`
    typeL2hMap : Array Nat                  := #[]
    termH2lMap : HashMap Nat Nat            := {}
    -- This field should be in sync with `LamReif.State.varVal`
    termL2hMap : Array Nat                  := #[]
    etomH2lMap : HashMap Nat Nat            := {}
    etomL2hMap : HashMap Nat Nat            := {}
    -- Maps from high-level chkstep to low-level chkstep
    csH2lMap   : HashMap ChkStep ChkStep    := {}

  abbrev TransM := StateRefT TState ReifM

  variable {ω : Type} [BEq ω] [Hashable ω]

  variable {μ : Type} [BEq μ] [Hashable μ]

  @[always_inline]
  instance : Monad TransM :=
    let i := inferInstanceAs (Monad TransM);
    { pure := i.pure, bind := i.bind }

  instance : Inhabited (TransM α) where
    default := fun _ => throw default

  #genMonadState TransM

  def transTypeAtom (a : Nat) (val : Expr × Level) : TransM Nat := do
    let typeH2lMap ← getTypeH2lMap
    match typeH2lMap.find? a with
    | .some n => return n
    | .none =>
      let idx := typeH2lMap.size
      setTypeH2lMap (typeH2lMap.insert a idx)
      setTypeL2hMap ((← getTypeL2hMap).push a)
      setTyVal ((← getTyVal).push val)
      setTyVarMap ((← getTyVarMap).insert val.fst idx)
      return idx

  /--
    When translating `Lam` to `Lam` in `Lam2Lam`, make sure that
      the `LamSort` in this `val` is already translated.
  -/
  def transTermAtom (a : Nat) (val : Expr × LamSort) : TransM Nat := do
    let termH2lMap ← getTermH2lMap
    match termH2lMap.find? a with
    | .some n => return n
    | .none =>
      let idx := termH2lMap.size
      setTermH2lMap (termH2lMap.insert a idx)
      setTermL2hMap ((← getTermL2hMap).push a)
      setVarVal ((← getVarVal).push val)
      setVarMap ((← getVarMap).insert val.fst idx)
      return idx

  def addEtomTranslation (eH : Nat) (eL : Nat) : TransM Unit := do
    setEtomH2lMap ((← getEtomH2lMap).insert eH eL)
    setEtomL2hMap ((← getEtomL2hMap).insert eL eH)

  -- We're translating `Lam` to `Lam`. We call the first `Lam`
  --   the `high-level` one, and the second `Lam` the `low-level` one.

  def transLamSort (ref : State) : LamSort → TransM LamSort
  | .atom n => do
    let (val, _) ← (lookupTyVal! n).run ref
    return .atom (← transTypeAtom n val)
  | .base b => return .base b
  | .func arg res => .func <$> transLamSort ref arg <*> transLamSort ref res

  private def transLamBaseTermILErr := "transLamBaseTerm :: Import versions of logical constants should not occur here"

  def transLamBaseTerm (ref : State) : LamBaseTerm → TransM LamBaseTerm
  | .eqI _ => throwError transLamBaseTermILErr
  | .forallEI _ => throwError transLamBaseTermILErr
  | .existEI _ => throwError transLamBaseTermILErr
  | .iteI _ => throwError transLamBaseTermILErr
  | .eq s => .eq <$> transLamSort ref s
  | .forallE s => .forallE <$> transLamSort ref s
  | .existE s => .existE <$> transLamSort ref s
  | .ite s => .ite <$> transLamSort ref s
  | b => return b

  mutual

    partial def transEtom (ref : State) (e : Nat) : TransM Nat := do
      if !((← getEtomH2lMap).contains e) then
        let (cs, _) ← (lookupEtomChkStep! e).run ref
        trace[auto.buildChecker] "Collecting for etom {e} by ChkStep {cs}"
        let _ ← processChkStep ref cs
      let .some n := (← getEtomH2lMap).find? e
        | throwError "transEtom :: Cannot find translation of etom {e}"
      return n

    partial def transLamTerm (ref : State) : LamTerm → TransM LamTerm
    | .atom n => do
      let ((e, s), _) ← (lookupVarVal! n).run ref
      let s' ← transLamSort ref s
      return .atom (← transTermAtom n (e, s'))
    | .etom n => return .etom (← transEtom ref n)
    | .base b => .base <$> transLamBaseTerm ref b
    | .bvar n => return .bvar n
    | .lam s t => .lam <$> transLamSort ref s <*> transLamTerm ref t
    | .app s fn arg => .app <$> transLamSort ref s <*> transLamTerm ref fn <*> transLamTerm ref arg

    partial def transREntry (ref : State) : REntry → TransM REntry
    | .wf lctx s t => do
      return .wf (← lctx.mapM (transLamSort ref)) (← transLamSort ref s) (← transLamTerm ref t)
    | .valid lctx t => do
      return .valid (← lctx.mapM (transLamSort ref)) (← transLamTerm ref t)
    | .nonempty s => .nonempty <$> transLamSort ref s

    partial def transPos (ref : State) (n : Nat) : TransM Nat := do
      let (hre, _) ← (lookupRTable! n).run ref
      collectProofFor ref hre
      lookupREntryPos! (← transREntry ref hre)

    partial def transChkStep (ref : State) : ChkStep → TransM ChkStep
    | .c cs => ChkStep.c <$>
      match cs with
      | .validOfHeadBeta pos => return .validOfHeadBeta (← transPos ref pos)
      | .validOfBetaBounded pos bound => return .validOfBetaBounded (← transPos ref pos) bound
      | .validOfExtensionalize pos => return .validOfExtensionalize (← transPos ref pos)
      | .validOfEqSymm pos => return .validOfEqSymm (← transPos ref pos)
      | .validOfMp pos rw => return .validOfMp (← transPos ref pos) (← transPos ref rw)
      | .validOfMpAll pos rw => return .validOfMpAll (← transPos ref pos) (← transPos ref rw)
      | .validOfCongrArg pos rw => return .validOfCongrArg (← transPos ref pos) (← transPos ref rw)
      | .validOfCongrFun pos rw => return .validOfCongrFun (← transPos ref pos) (← transPos ref rw)
      | .validOfCongr pos rwFn rwArg => return .validOfCongr (← transPos ref pos) (← transPos ref rwFn) (← transPos ref rwArg)
      | .validOfCongrArgs pos rws => return .validOfCongrArgs (← transPos ref pos) (← rws.mapM (transPos ref))
      | .validOfCongrFunN pos rw n => return .validOfCongrFunN (← transPos ref pos) (← transPos ref rw) n
      | .validOfCongrs pos rwFn rwArgs => return .validOfCongrs (← transPos ref pos) (← transPos ref rwFn) (← rwArgs.mapM (transPos ref))
    | .ca cs => ChkStep.ca <$>
      match cs with
      | .validOfEtaExpand1At pos occ => return .validOfEtaExpand1At (← transPos ref pos) occ
      | .validOfEtaReduce1At pos occ => return .validOfEtaReduce1At (← transPos ref pos) occ
      | .validOfEtaExpandNAt pos n occ => return .validOfEtaExpandNAt (← transPos ref pos) n occ
      | .validOfEtaReduceNAt pos n occ => return .validOfEtaReduceNAt (← transPos ref pos) n occ
      | .validOfExtensionalizeEqAt pos occ => return .validOfExtensionalizeEqAt (← transPos ref pos) occ
      | .validOfExtensionalizeEqFNAt pos n occ => return .validOfExtensionalizeEqFNAt (← transPos ref pos) n occ
      | .validOfIntensionalizeEqAt pos occ => return .validOfIntensionalizeEqAt (← transPos ref pos) occ
    | .e cs => ChkStep.e <$>
      match cs with
      | .skolemize pos => return .skolemize (← transPos ref pos)
      | .define t => return .define (← transLamTerm ref t)
    | .f cs => ChkStep.f <$>
      match cs with
      | .boolFacts => return .boolFacts
      | .iteSpec s => do return .iteSpec (← transLamSort ref s)
    | .i cs => ChkStep.i <$>
      match cs with
      | .validOfBVarLower pv pn => return .validOfBVarLower (← transPos ref pv) (← transPos ref pn)
      | .validOfBVarLowers pv pns => return .validOfBVarLowers (← transPos ref pv) (← pns.mapM (transPos ref))
      | .validOfImp p₁₂ p₁ => return .validOfImp (← transPos ref p₁₂) (← transPos ref p₁)
      | .validOfImps imp ps => return .validOfImps (← transPos ref imp) (← ps.mapM (transPos ref))
      | .validOfInstantiate1 pos arg => return .validOfInstantiate1 (← transPos ref pos) (← transLamTerm ref arg)
      | .validOfInstantiate pos args => return .validOfInstantiate (← transPos ref pos) (← args.mapM (transLamTerm ref))
      | .validOfInstantiateRev pos args => return .validOfInstantiateRev (← transPos ref pos) (← args.mapM (transLamTerm ref))
      | .validOfEqualize pos occ => return .validOfEqualize (← transPos ref pos) occ
      | .validOfAndLeft pos occ => return .validOfAndLeft (← transPos ref pos) occ
      | .validOfAndRight pos occ => return .validOfAndRight (← transPos ref pos) occ
    | .l cs => ChkStep.l <$>
      match cs with
      | .validOfIntro1F pos => return .validOfIntro1F (← transPos ref pos)
      | .validOfIntro1H pos => return .validOfIntro1H (← transPos ref pos)
      | .validOfIntros pos idx => return .validOfIntros (← transPos ref pos) idx
      | .validOfRevert pos => return .validOfRevert (← transPos ref pos)
      | .validOfReverts pos idx => return .validOfReverts (← transPos ref pos) idx
      | .validOfAppend pos ex => return .validOfAppend (← transPos ref pos) (← ex.mapM (transLamSort ref))
      | .validOfPrepend pos ex => return .validOfPrepend (← transPos ref pos) (← ex.mapM (transLamSort ref))
    | .n cs => ChkStep.n <$>
      match cs with
      | .nonemptyOfAtom n => do
        let .atom n' ← transLamTerm ref (.atom n)
          | throwError "transChkStep :: Unexpected error"
        return .nonemptyOfAtom n'
      | .nonemptyOfEtom n => do
        let .etom n' ← transLamTerm ref (.etom n)
          | throwError "transChkStep :: Unexpected error"
        return .nonemptyOfEtom n'
    | .p cs pos occ => return ChkStep.p cs (← transPos ref pos) occ
    | .w cs => ChkStep.w <$>
      match cs with
      | .wfOfCheck lctx t => return .wfOfCheck (← lctx.mapM (transLamSort ref)) (← transLamTerm ref t)
      | .wfOfAppend pos ex => return .wfOfAppend (← transPos ref pos) (← ex.mapM (transLamSort ref))
      | .wfOfPrepend pos ex => return .wfOfPrepend (← transPos ref pos) (← ex.mapM (transLamSort ref))
      | .wfOfHeadBeta pos => return .wfOfHeadBeta (← transPos ref pos)
      | .wfOfBetaBounded pos bound => return .wfOfBetaBounded (← transPos ref pos) bound

    partial def processChkStep (ref : State) (cs : ChkStep) : TransM EvalResult := do
      if let .some cs' := (← getCsH2lMap).find? cs then
        return ← LamReif.lookupChkStepResult! cs'
      let cs' ← transChkStep ref cs
      setCsH2lMap ((← getCsH2lMap).insert cs cs')
      let (true, er) ← newChkStep cs' .none
        | throwError "processChkStep :: Unexpected error"
      trace[auto.buildChecker] "Checkstep {cs} translated to {cs'}, producing {er}"
      match er with
      | .newEtomWithValid .. => do
        let newEtoms ← LamReif.lookupChkStepEtom! cs'
        let oldEtoms ← (LamReif.lookupChkStepEtom! cs).run' ref
        for (new, old) in newEtoms.zip oldEtoms do
          addEtomTranslation old new
      | _ => pure .unit
      return er

    -- Collect essential chksteps and assertions from the high-level `lam`
    --   into the low-level `lam` such that the low-level `lam` proves `re`
    partial def collectProofFor (ref : State) (hre : REntry) : TransM Unit := do
      if let .some _ := (← getChkMap).find? hre then
        return
      let (highLvlProof, _) ← (lookupREntryProof! hre).run ref
      match highLvlProof with
      | .chkStep cs =>
        trace[auto.buildChecker] "Collecting for {hre} by ChkStep {cs}"
        let er ← processChkStep ref cs
        match er with
        | .fail => throwError "collectProofFor :: Unexpected evaluation result"
        | .addEntry reNew => do
          let expectedEntry ← transREntry ref hre
          if expectedEntry != reNew then throwError "collectProofFor :: Entry mismatch"
        | .newEtomWithValid _ lctx t => do
          let expectedEntry ← transREntry ref hre
          if expectedEntry != .valid lctx t then throwError "collectProofFor :: Entry mismatch"
      | .inhabitation e _ =>
        let .nonempty hs := hre
          | throwError "collectProofFor :: Unexpected error"
        let s ← transLamSort ref hs
        newInhabitation e s
        trace[auto.buildChecker] "Inhabitation fact {hs} translated to {s}"
      | .assertion e _ =>
        let .valid [] ht := hre
          | throwError "collectProofFor :: Unexpected error"
        let t ← transLamTerm ref ht
        newAssertion e t
        trace[auto.buildChecker] "Import fact {ht} translated to {t}"

  end

  /--
    Delete irrelevant Valuations and ChkSteps, but make sure that
      entries in `res` are still provable
  -/
  def optimizedStateFor (res : Array REntry) : LamReif.ReifM State := do
    let ref ← get
    let (_, s') ← ((res.foldlM (fun _ re => collectProofFor ref re) ()).run {}).run { u := ref.u }
    return s'

end Lam2Lam

namespace LamReif
open Embedding.Lam

/-- Build optimized checker = Optimize state + Build full checker -/
def buildOptimizedCheckerExprFor (re : REntry) : ReifM Expr := do
  let s' ← Lam2Lam.optimizedStateFor #[re]
  let (e, _) ← (buildFullCheckerExprFor re).run s'
  return e

register_option auto.optimizeCheckerProof : Bool := {
  defValue := true
  descr := "Enable/Disable checker proof optimization"
}

/-- Decide whether to optimize based on option -/
def buildCheckerExprFor (re : REntry) : ReifM Expr := do
  match auto.optimizeCheckerProof.get (← getOptions) with
  | true => buildOptimizedCheckerExprFor re
  | false => buildFullCheckerExprFor re

end Auto.LamReif
